// This file is auto-generated by @hey-api/openapi-ts

export const QuoteSaverWithdrawResponseSchema = {
  type: "object",
  required: [
    "inbound_address",
    "expected_amount_out",
    "dust_amount",
    "memo",
    "outbound_delay_blocks",
    "outbound_delay_seconds",
    "fees",
    "slippage_bps",
    "warning",
    "notes",
    "expiry",
    "recommended_gas_rate",
    "gas_rate_units",
  ],
  properties: {
    warning: {
      type: "string",
      description: "static warning message",
      example:
        "Do not cache this response. Do not send funds after the expiry.",
    },
    recommended_gas_rate: {
      description:
        "the recommended gas rate to use for the inbound to ensure timely confirmation",
      type: "string",
      example: "10",
    },
    fees: {
      $ref: "#/components/schemas/QuoteFees",
    },
    inbound_confirmation_seconds: {
      description:
        "the approximate seconds for block confirmations required before processing",
      type: "integer",
      format: "int64",
    },
    router: {
      type: "string",
      description: "the EVM chain router contract address",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
    },
    dust_threshold: {
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
      type: "string",
    },
    expected_amount_out: {
      example: "10000",
      type: "string",
      description:
        "the amount of the target asset the user can expect to withdraw after fees in 1e8 decimals",
    },
    inbound_confirmation_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the approximate number of source chain blocks required before processing",
    },
    expiry: {
      type: "integer",
      format: "int64",
      description: "expiration timestamp in unix seconds",
      example: 1671660285,
    },
    notes: {
      type: "string",
      description: "chain specific quote notes",
      example:
        "Transfer the inbound_address the asset with the memo. Do not use multi-in, multi-out transactions.",
    },
    gas_rate_units: {
      type: "string",
      example: "gwei",
      description: "the units of the recommended gas rate",
    },
    dust_amount: {
      type: "string",
      description:
        "the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo",
      example: "10000",
    },
    inbound_address: {
      description:
        "the inbound address for the transaction on the source chain",
      example: "bc1qjk3xzu5slu7mtmc8jc9yed3zqvkhkttm700g9a",
      type: "string",
    },
    outbound_delay_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for the outbound delay before it will be sent",
    },
    recommended_min_amount_in: {
      example: "15000",
      type: "string",
      description:
        "The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.",
    },
    memo: {
      type: "string",
      description:
        "generated memo for the withdraw, the client can use this OR send the dust amount",
      example:
        "-:ETH.ETH:0x1c7b17362c84287bd1184447e6dfeaf920c31bbe:1440450000:thor17gw75axcnr8747pkanye45pnrwk7p9c3cqncsv:100",
    },
    outbound_delay_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the number of thorchain blocks the outbound will be delayed",
    },
  },
} as const;

export const YggdrasilVaultSchema = {
  type: "object",
  required: ["coins", "routers", "status", "bond", "total_value", "addresses"],
  properties: {
    pending_tx_block_heights: {
      type: "array",
      items: {
        type: "integer",
        format: "int64",
      },
    },
    inbound_tx_count: {
      type: "integer",
      format: "int64",
    },
    membership: {
      type: "array",
      description:
        "the list of node public keys which are members of the vault",
      items: {
        type: "string",
      },
    },
    chains: {
      type: "array",
      items: {
        type: "string",
      },
    },
    routers: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultRouter",
      },
    },
    status: {
      type: "string",
    },
    pub_key: {
      type: "string",
    },
    status_since: {
      format: "int64",
      type: "integer",
    },
    bond: {
      type: "string",
      description: "current node bond",
      example: "123456789",
    },
    block_height: {
      format: "int64",
      type: "integer",
    },
    type: {
      type: "string",
      enum: ["AsgardVault", "YggdrasilVault"],
    },
    outbound_tx_count: {
      format: "int64",
      type: "integer",
    },
    total_value: {
      type: "string",
      description: "value in rune of the vault's assets",
      example: "83456789",
    },
    addresses: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultAddress",
      },
    },
    coins: {
      items: {
        $ref: "#/components/schemas/Coin",
      },
      type: "array",
    },
  },
} as const;

export const StreamingSwapsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/StreamingSwap",
  },
} as const;

export const SwapQueueResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/MsgSwap",
  },
} as const;

export const TradeAccountResponseSchema = {
  type: "object",
  required: ["asset", "units", "owner"],
  properties: {
    asset: {
      type: "string",
      example: "BTC~BTC",
      description: 'trade account asset with "~" separator',
    },
    units: {
      type: "string",
      description: "units of trade asset belonging to this owner",
    },
    owner: {
      description: "thor address of trade account owner",
      type: "string",
    },
    last_add_height: {
      type: "integer",
      format: "int64",
      description:
        "last thorchain height trade assets were added to trade account",
    },
    last_withdraw_height: {
      description:
        "last thorchain height trade assets were withdrawn from trade account",
      type: "integer",
      format: "int64",
    },
  },
} as const;

export const ScheduledResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/TxOutItem",
  },
} as const;

export const MimirResponseSchema = {
  example: {
    NODEOPERATORFEE: 2000,
    NUMBEROFNEWNODESPERCHURN: 2,
  },
  type: "object",
  additionalProperties: {
    type: "string",
  },
} as const;

export const CoinSchema = {
  type: "object",
  required: ["asset", "amount"],
  properties: {
    asset: {
      type: "string",
      example: "BTC.BTC",
    },
    amount: {
      type: "string",
      example: "100000",
    },
    decimals: {
      type: "integer",
      format: "int64",
      example: 6,
    },
  },
} as const;

export const BlockTxSchema = {
  required: ["hash", "tx", "result"],
  properties: {
    hash: {
      type: "string",
      example:
        "223BF64D4A01074DC523A80E76B9BBC786C791FB0A1893AC5B14866356FCFD6C",
    },
    tx: {
      type: "object",
      additionalProperties: true,
    },
    result: {
      properties: {
        events: {
          type: "array",
          nullable: true,
          items: {
            type: "object",
            additionalProperties: {
              type: "string",
            },
          },
        },
        codespace: {
          example: "ibc",
          type: "string",
        },
        code: {
          example: 0,
          type: "integer",
          format: "int64",
        },
        data: {
          type: "string",
          example: "",
        },
        log: {
          type: "string",
          example: "not enough gas",
        },
        info: {
          type: "string",
          example: "",
        },
        gas_wanted: {
          type: "string",
          example: "100",
        },
        gas_used: {
          type: "string",
          example: "100",
        },
      },
      type: "object",
    },
  },
  type: "object",
} as const;

export const PoolSlipResponseSchema = {
  type: "array",
  title: "PoolSlipResponse",
  items: {
    type: "object",
    required: ["asset", "pool_slip", "rollup_count", "long_rollup", "rollup"],
    properties: {
      asset: {
        type: "string",
        example: "BTC.BTC",
      },
      pool_slip: {
        type: "integer",
        format: "int64",
        example: 5,
        description: "Pool slip for this asset's pool for the current height",
      },
      rollup_count: {
        type: "integer",
        format: "int64",
        example: 300,
        description:
          "Number of stored pool slips contributing to the current stored rollup",
      },
      long_rollup: {
        type: "integer",
        format: "int64",
        example: 1500,
        description: "Median of rollup snapshots over a long period",
      },
      rollup: {
        type: "integer",
        format: "int64",
        example: 1500,
        description:
          "Stored sum of pool slips over a number of previous block heights",
      },
      summed_rollup: {
        example: 1500,
        description:
          "Summed pool slips over a number of previous block heights, to checksum the stored rollup",
        type: "integer",
        format: "int64",
      },
    },
  },
} as const;

export const BorrowerResponseSchema = {
  $ref: "#/components/schemas/Borrower",
} as const;

export const LiquidityProviderResponseSchema = {
  $ref: "#/components/schemas/LiquidityProvider",
} as const;

export const ConstantsResponseSchema = {
  type: "object",
  properties: {
    int_64_values: {
      type: "object",
      additionalProperties: {
        type: "string",
      },
      example: {
        AsgardSize: 40,
      },
    },
    bool_values: {
      type: "object",
      additionalProperties: {
        type: "string",
      },
      example: {
        StrictBondLiquidityRatio: true,
      },
    },
    string_values: {
      example: {
        DefaultPoolStatus: "Staged",
      },
      type: "object",
      additionalProperties: {
        type: "string",
      },
    },
  },
} as const;

export const baseQuoteResponseSchema = {
  properties: {
    outbound_delay_blocks: {
      format: "int64",
      description:
        "the number of thorchain blocks the outbound will be delayed",
      type: "integer",
    },
    warning: {
      type: "string",
      description: "static warning message",
      example:
        "Do not cache this response. Do not send funds after the expiry.",
    },
    recommended_min_amount_in: {
      type: "string",
      description:
        "The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.",
      example: "15000",
    },
    inbound_address: {
      type: "string",
      description:
        "the inbound address for the transaction on the source chain",
      example: "bc1qjk3xzu5slu7mtmc8jc9yed3zqvkhkttm700g9a",
    },
    inbound_confirmation_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for block confirmations required before processing",
    },
    expiry: {
      type: "integer",
      format: "int64",
      description: "expiration timestamp in unix seconds",
      example: 1671660285,
    },
    recommended_gas_rate: {
      type: "string",
      example: "10",
      description:
        "the recommended gas rate to use for the inbound to ensure timely confirmation",
    },
    gas_rate_units: {
      example: "gwei",
      description: "the units of the recommended gas rate",
      type: "string",
    },
    dust_threshold: {
      type: "string",
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
    },
    inbound_confirmation_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the approximate number of source chain blocks required before processing",
    },
    outbound_delay_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for the outbound delay before it will be sent",
    },
    fees: {
      $ref: "#/components/schemas/QuoteFees",
    },
    router: {
      type: "string",
      description: "the EVM chain router contract address",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
    },
    notes: {
      type: "string",
      description: "chain specific quote notes",
      example:
        "Transfer the inbound_address the asset with the memo. Do not use multi-in, multi-out transactions.",
    },
  },
} as const;

export const VaultSchema = {
  type: "object",
  required: ["coins", "status", "routers", "addresses"],
  properties: {
    coins: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Coin",
      },
    },
    status: {
      type: "string",
    },
    outbound_tx_count: {
      type: "integer",
      format: "int64",
    },
    addresses: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultAddress",
      },
    },
    block_height: {
      type: "integer",
      format: "int64",
    },
    status_since: {
      type: "integer",
      format: "int64",
    },
    inbound_tx_count: {
      type: "integer",
      format: "int64",
    },
    routers: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultRouter",
      },
    },
    pub_key: {
      type: "string",
    },
    chains: {
      type: "array",
      items: {
        type: "string",
      },
    },
    pending_tx_block_heights: {
      type: "array",
      items: {
        type: "integer",
        format: "int64",
      },
    },
    frozen: {
      type: "array",
      items: {
        type: "string",
      },
    },
    membership: {
      type: "array",
      description:
        "the list of node public keys which are members of the vault",
      items: {
        type: "string",
      },
    },
    type: {
      enum: ["AsgardVault", "YggdrasilVault"],
      type: "string",
    },
  },
} as const;

export const VaultInfoSchema = {
  type: "object",
  required: ["pub_key", "routers"],
  properties: {
    pub_key: {
      type: "string",
      example:
        "thorpub1addwnpepq068dr0x7ue973drmq4eqmzhcq3650n7nx5fhgn9gl207luxp6vaklu52tc",
    },
    routers: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultRouter",
      },
    },
  },
} as const;

export const TxOutItemSchema = {
  type: "object",
  required: ["chain", "to_address", "coin", "max_gas"],
  properties: {
    out_hash: {
      type: "string",
      example:
        "0D0B2FDB6DAD6E5FD3C5E46D39128F9DA15E96F0B2CC054CE059EA3532B150FB",
    },
    height: {
      type: "integer",
      format: "int64",
      example: 1234,
    },
    memo: {
      example:
        "OUT:208BF0ACD78C89A0534B0457BA0867B101961A2319C1E49DD28676526904BBEA",
      type: "string",
    },
    in_hash: {
      type: "string",
      example:
        "208BF0ACD78C89A0534B0457BA0867B101961A2319C1E49DD28676526904BBEA",
    },
    vault_pub_key: {
      type: "string",
      example:
        "thorpub1addwnpepqt45wmsxj29xpgdrdsvg2h3dx68qeapgykw3hlyj6vuds2r0pnkwx5gt9m4",
    },
    coin: {
      $ref: "#/components/schemas/Coin",
    },
    max_gas: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Coin",
      },
    },
    gas_rate: {
      type: "integer",
      format: "int64",
    },
    clout_spent: {
      type: "string",
      description: "clout spent in RUNE for the outbound",
      example: "1234",
    },
    chain: {
      type: "string",
      example: "ETH",
    },
    to_address: {
      type: "string",
      example: "0x66fb1cd65b97fa40457b90b7d1ca6b92cb64b32b",
    },
  },
} as const;

export const KeygenMetricSchema = {
  type: "object",
  required: ["node_tss_times"],
  properties: {
    pub_key: {
      type: "string",
    },
    node_tss_times: {
      type: "array",
      items: {
        properties: {
          address: {
            type: "string",
          },
          tss_time: {
            type: "string",
          },
        },
        type: "object",
        title: "NodeKeygenMetric",
      },
    },
  },
} as const;

export const BorrowerSchema = {
  type: "object",
  required: [
    "owner",
    "asset",
    "debt_issued",
    "debt_repaid",
    "debt_current",
    "collateral_deposited",
    "collateral_withdrawn",
    "collateral_current",
    "last_open_height",
    "last_repay_height",
  ],
  properties: {
    debt_current: {
      type: "string",
      example: "123456",
    },
    collateral_deposited: {
      type: "string",
      example: "123456",
    },
    asset: {
      type: "string",
      example: "BTC.BTC",
    },
    debt_repaid: {
      type: "string",
      example: "123456",
    },
    collateral_withdrawn: {
      type: "string",
      example: "123456",
    },
    collateral_current: {
      type: "string",
      example: "123456",
    },
    last_open_height: {
      example: 82745,
      type: "integer",
      format: "int64",
    },
    last_repay_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    owner: {
      type: "string",
      example: "bc1qn9esxuw8ca7ts8l6w66kdh800s09msvutydc46",
    },
    debt_issued: {
      type: "string",
      example: "123456",
    },
  },
} as const;

export const MsgSwapSchema = {
  properties: {
    aggregator_target_limit: {
      description:
        "the minimum amount of SwapOut asset to receive (else cancelling the SwapOut and receiving THORChain's output)",
      type: "string",
    },
    order_type: {
      description:
        "market if immediately completed or refunded, limit if held until fulfillable",
      type: "string",
    },
    destination: {
      type: "string",
      example: "0x66fb1cd65b97fa40457b90b7d1ca6b92cb64b32b",
      description: "the destination address to receive the swap output",
    },
    trade_target: {
      type: "string",
      description:
        "the minimum amount of output asset to receive (else cancelling and refunding the swap)",
    },
    affiliate_basis_points: {
      type: "string",
      description: "the affiliate fee in basis points",
    },
    aggregator: {
      type: "string",
      description:
        "the contract address if an aggregator is specified for a non-THORChain SwapOut",
    },
    aggregator_target_address: {
      type: "string",
      description: "the desired output asset of the aggregator SwapOut",
    },
    stream_quantity: {
      format: "int64",
      description: "number of swaps to execute in a streaming swap",
      type: "integer",
    },
    stream_interval: {
      type: "integer",
      format: "int64",
      description: "the interval (in blocks) to execute the streaming swap",
    },
    tx: {
      $ref: "#/components/schemas/Tx",
    },
    target_asset: {
      example: "ETH.ETH",
      description: "the asset to be swapped to",
      type: "string",
    },
    affiliate_address: {
      type: "string",
      example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
      description: "the affiliate address which will receive any affiliate fee",
    },
    signer: {
      type: "string",
      description: "the signer (sender) of the transaction",
    },
  },
  type: "object",
  required: ["tx", "target_asset", "trade_target", "affiliate_basis_points"],
} as const;

export const TssMetricSchema = {
  type: "object",
  properties: {
    address: {
      type: "string",
    },
    tss_time: {
      format: "int64",
      type: "integer",
    },
  },
} as const;

export const QuoteLoanOpenResponseSchema = {
  required: [
    "expected_amount_out",
    "expected_collateralization_ratio",
    "expected_collateral_deposited",
    "expected_debt_issued",
    "outbound_delay_blocks",
    "outbound_delay_seconds",
    "fees",
    "warning",
    "notes",
    "expiry",
    "streaming_swap_blocks",
    "streaming_swap_seconds",
    "total_open_loan_seconds",
    "recommended_gas_rate",
    "gas_rate_units",
  ],
  properties: {
    outbound_delay_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for the outbound delay before it will be sent",
    },
    fees: {
      $ref: "#/components/schemas/QuoteFees",
    },
    expiry: {
      description: "expiration timestamp in unix seconds",
      example: 1671660285,
      type: "integer",
      format: "int64",
    },
    warning: {
      type: "string",
      description: "static warning message",
      example:
        "Do not cache this response. Do not send funds after the expiry.",
    },
    notes: {
      type: "string",
      description: "chain specific quote notes",
      example:
        "Transfer the inbound_address the asset with the memo. Do not use multi-in, multi-out transactions.",
    },
    inbound_confirmation_blocks: {
      description:
        "the approximate number of source chain blocks required before processing",
      type: "integer",
      format: "int64",
    },
    inbound_confirmation_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for block confirmations required before processing",
    },
    dust_threshold: {
      type: "string",
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
    },
    recommended_min_amount_in: {
      description:
        "The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.",
      example: "15000",
      type: "string",
    },
    recommended_gas_rate: {
      example: "10",
      description:
        "the recommended gas rate to use for the inbound to ensure timely confirmation",
      type: "string",
    },
    gas_rate_units: {
      type: "string",
      example: "gwei",
      description: "the units of the recommended gas rate",
    },
    expected_collateral_deposited: {
      type: "string",
      description: "the expected amount of collateral increase on the loan",
      example: "1000000",
    },
    streaming_swap_seconds: {
      format: "int64",
      description:
        "The approximate number of seconds taken by the streaming swaps involved in the open loan process.",
      example: 600,
      type: "integer",
    },
    inbound_address: {
      type: "string",
      description:
        "the inbound address for the transaction on the source chain",
      example: "bc1qjk3xzu5slu7mtmc8jc9yed3zqvkhkttm700g9a",
    },
    outbound_delay_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the number of thorchain blocks the outbound will be delayed",
    },
    streaming_swap_blocks: {
      type: "integer",
      format: "int64",
      description:
        "The number of blocks involved in the streaming swaps during the open loan process.",
      example: 10,
    },
    router: {
      type: "string",
      description: "the EVM chain router contract address",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
    },
    expected_debt_issued: {
      description: "the expected amount of TOR debt increase on the loan",
      example: "1000000",
      type: "string",
    },
    expected_collateralization_ratio: {
      type: "string",
      description: "the expected collateralization ratio in basis points",
      example: "30000",
    },
    total_open_loan_seconds: {
      example: 600,
      type: "integer",
      format: "int64",
      description:
        "The total expected duration for a open loan, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.",
    },
    memo: {
      type: "string",
      description: "generated memo for the loan open",
      example: "$+:ETH.ETH:0x1c7b17362c84287bd1184447e6dfeaf920c31bbe",
    },
    expected_amount_out: {
      type: "string",
      description:
        "the amount of the target asset the user can expect to receive after fees in 1e8 decimals",
      example: "10000",
    },
  },
  type: "object",
} as const;

export const ThornameSchema = {
  type: "object",
  required: ["preferred_asset", "aliases"],
  properties: {
    name: {
      type: "string",
      example: "thor",
    },
    expire_block_height: {
      type: "integer",
      format: "int64",
      example: 1234,
    },
    owner: {
      type: "string",
      example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
    },
    preferred_asset: {
      type: "string",
      example: "BTC.BTC",
    },
    affiliate_collector_rune: {
      type: "string",
      example: "100",
      description:
        "Amount of RUNE currently accrued by this thorname in affiliate fees waiting to be swapped to preferred asset.",
    },
    aliases: {
      type: "array",
      items: {
        $ref: "#/components/schemas/ThornameAlias",
      },
    },
  },
} as const;

export const PoolsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/Pool",
  },
} as const;

export const VersionResponseSchema = {
  required: ["current", "next", "querier"],
  properties: {
    next_since_height: {
      example: 2000000,
      description: "height at which the minimum joining version last changed",
      type: "integer",
      format: "int64",
    },
    querier: {
      description: "querier version",
      type: "string",
      example: "0.16.0",
    },
    current: {
      type: "string",
      example: "0.17.0",
      description: "current version",
    },
    next: {
      type: "string",
      example: "0.18.0",
      description: "next version (minimum version for a node to become Active)",
    },
  },
  type: "object",
} as const;

export const UpgradeVotesResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/UpgradeVote",
  },
} as const;

export const KeygenResponseSchema = {
  type: "object",
  required: ["keygen_block", "signature"],
  properties: {
    keygen_block: {
      properties: {
        height: {
          format: "int64",
          description: "the height of the keygen block",
          type: "integer",
        },
        keygens: {
          type: "array",
          items: {
            type: "object",
            title: "keygen",
            properties: {
              type: {
                type: "string",
              },
              members: {
                type: "array",
                items: {
                  type: "string",
                  description: "pubkeys of the keygen block member nodes",
                },
              },
              id: {
                type: "string",
              },
            },
          },
        },
      },
      type: "object",
      title: "KeygenBlock",
      required: ["keygens"],
    },
    signature: {
      type: "string",
    },
  },
} as const;

export const ThornameResponseSchema = {
  $ref: "#/components/schemas/Thorname",
} as const;

export const PoolSchema = {
  properties: {
    status: {
      type: "string",
      example: "Available",
    },
    balance_asset: {
      type: "string",
      example: "3197744873",
    },
    LP_units: {
      type: "string",
      description: "the total pool liquidity provider units",
      example: "14694928607473",
    },
    savers_capacity_remaining: {
      example: "1000",
      description: "amount of remaining capacity in asset",
      type: "string",
    },
    synth_mint_paused: {
      type: "boolean",
      example: true,
      description: "whether additional synths cannot be minted",
    },
    loan_collateral_remaining: {
      type: "string",
      example: "123456",
      description: "the amount of remaining collateral collects for loans",
    },
    pending_inbound_asset: {
      example: "101713319",
      type: "string",
    },
    pool_units: {
      type: "string",
      description:
        "the total pool units, this is the sum of LP and synth units",
      example: "14694928607473",
    },
    synth_supply_remaining: {
      example: "123456",
      description:
        "the amount of synth supply remaining before the current max supply is reached",
      type: "string",
    },
    loan_collateral: {
      type: "string",
      example: "123456",
      description: "the amount of collateral collects for loans",
    },
    asset: {
      type: "string",
      example: "BTC.BTC",
    },
    short_code: {
      type: "string",
      example: "b",
    },
    balance_rune: {
      type: "string",
      example: "13460619152985",
    },
    asset_tor_price: {
      type: "string",
      example: "123456",
      description: "the USD (TOR) price of the asset in 1e8",
    },
    savers_depth: {
      type: "string",
      example: "199998",
      description: "the balance of L1 asset deposited into the Savers Vault",
    },
    savers_units: {
      example: "199998",
      description: "the number of units owned by Savers",
      type: "string",
    },
    loan_cr: {
      type: "string",
      example: "123456",
      description: "the current loan collateralization ratio",
    },
    decimals: {
      type: "integer",
      format: "int64",
      example: 6,
    },
    pending_inbound_rune: {
      type: "string",
      example: "464993836",
    },
    synth_units: {
      type: "string",
      description: "the total synth units in the pool",
      example: "0",
    },
    synth_supply: {
      type: "string",
      description: "the total supply of synths for the asset",
      example: "0",
    },
    savers_fill_bps: {
      type: "string",
      example: "4500",
      description:
        "the filled savers capacity in basis points, 4500/10000 = 45%",
    },
    derived_depth_bps: {
      type: "string",
      example: "123456",
      description:
        "the depth of the derived virtual pool relative to L1 pool (in basis points)",
    },
  },
  type: "object",
  required: [
    "asset",
    "status",
    "pending_inbound_asset",
    "pending_inbound_rune",
    "balance_asset",
    "balance_rune",
    "asset_tor_price",
    "pool_units",
    "LP_units",
    "synth_units",
    "synth_supply",
    "savers_depth",
    "savers_units",
    "savers_fill_bps",
    "savers_capacity_remaining",
    "synth_mint_paused",
    "synth_supply_remaining",
    "loan_collateral",
    "loan_collateral_remaining",
    "loan_cr",
    "derived_depth_bps",
  ],
} as const;

export const VaultAddressSchema = {
  type: "object",
  required: ["chain", "address"],
  properties: {
    chain: {
      type: "string",
      example: "BTC",
    },
    address: {
      type: "string",
      example: "bc1qd45uzetakjvdy5ynjjyp4nlnj89am88e4e5jeq",
    },
  },
} as const;

export const RUNEPoolResponseSchema = {
  type: "object",
  required: ["pol", "providers", "reserve"],
  properties: {
    providers: {
      type: "object",
      required: [
        "units",
        "pending_units",
        "pending_rune",
        "value",
        "pnl",
        "rune_deposited",
        "rune_withdrawn",
        "current_deposit",
      ],
      properties: {
        current_deposit: {
          type: "string",
          example: "123456",
          description: "the current RUNE deposited by providers",
        },
        units: {
          description:
            "the units of RUNEPool owned by providers (including pending)",
          type: "string",
          example: "123456",
        },
        pending_units: {
          type: "string",
          example: "123456",
          description:
            "the units of RUNEPool owned by providers that remain pending",
        },
        pending_rune: {
          description: "the amount of RUNE pending",
          type: "string",
          example: "123456",
        },
        value: {
          type: "string",
          example: "123456",
          description:
            "the value of the provider share of the RUNEPool (includes pending RUNE)",
        },
        pnl: {
          example: "123456",
          description:
            "the profit and loss of the provider share of the RUNEPool",
          type: "string",
        },
      },
    },
    reserve: {
      type: "object",
      required: [
        "units",
        "value",
        "pnl",
        "rune_deposited",
        "rune_withdrawn",
        "current_deposit",
      ],
      properties: {
        units: {
          example: "123456",
          description: "the units of RUNEPool owned by the reserve",
          type: "string",
        },
        value: {
          type: "string",
          example: "123456",
          description: "the value of the reserve share of the RUNEPool",
        },
        pnl: {
          description:
            "the profit and loss of the reserve share of the RUNEPool",
          type: "string",
          example: "123456",
        },
        current_deposit: {
          description: "the current RUNE deposited by the reserve",
          type: "string",
          example: "123456",
        },
      },
    },
    pol: {
      $ref: "#/components/schemas/POL",
    },
  },
} as const;

export const NodesResponseSchema = {
  items: {
    $ref: "#/components/schemas/Node",
  },
  type: "array",
} as const;

export const SaversResponseSchema = {
  items: {
    $ref: "#/components/schemas/Saver",
  },
  type: "array",
} as const;

export const BorrowersResponseSchema = {
  items: {
    $ref: "#/components/schemas/Borrower",
  },
  type: "array",
} as const;

export const DerivedPoolSchema = {
  type: "object",
  required: [
    "asset",
    "status",
    "balance_asset",
    "balance_rune",
    "derived_depth_bps",
  ],
  properties: {
    decimals: {
      type: "integer",
      format: "int64",
      example: 6,
    },
    balance_asset: {
      type: "string",
      example: "3197744873",
    },
    balance_rune: {
      type: "string",
      example: "13460619152985",
    },
    derived_depth_bps: {
      type: "string",
      example: "123456",
      description:
        "the depth of the derived virtual pool relative to L1 pool (in basis points)",
    },
    asset: {
      type: "string",
      example: "BTC.BTC",
    },
    status: {
      type: "string",
      example: "Available",
    },
  },
} as const;

export const RUNEProvidersResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/RUNEProvider",
  },
} as const;

export const TxResponseSchema = {
  type: "object",
  properties: {
    observed_tx: {
      $ref: "#/components/schemas/ObservedTx",
    },
    consensus_height: {
      type: "integer",
      format: "int64",
      example: 7581321,
      description:
        "the thorchain height at which the inbound reached consensus",
    },
    finalised_height: {
      description: "the thorchain height at which the outbound was finalised",
      type: "integer",
      format: "int64",
      example: 7581334,
    },
    outbound_height: {
      example: 1234,
      description: "the thorchain height for which the outbound was scheduled",
      type: "integer",
      format: "int64",
    },
    keysign_metric: {
      $ref: "#/components/schemas/TssKeysignMetric",
    },
  },
} as const;

export const LastBlockResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/LastBlock",
  },
} as const;

export const ObservedTxSchema = {
  required: ["tx"],
  properties: {
    aggregator_target_limit: {
      type: "string",
      description:
        "the aggregator target asset limit provided to transferOutAndCall",
      example: "0x0a44986b70527154e9F4290eC14e5f0D1C861822",
    },
    signers: {
      type: "array",
      items: {
        type: "string",
        example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
      },
    },
    keysign_ms: {
      type: "integer",
      format: "int64",
      example: 10000,
    },
    out_hashes: {
      type: "array",
      items: {
        type: "string",
        example:
          "E17A0906E015F0C343691C18E475C8CB5F3F6C63F5BCDE0F3A341909763CC92B",
      },
    },
    status: {
      type: "string",
      enum: ["done", "incomplete"],
      example: "done",
    },
    tx: {
      $ref: "#/components/schemas/Tx",
    },
    aggregator: {
      description: "the outbound aggregator to use, will also match a suffix",
      example: "0x69800327b38A4CeF30367Dec3f64c2f2386f3848",
      type: "string",
    },
    aggregator_target: {
      type: "string",
      description: "the aggregator target asset provided to transferOutAndCall",
      example: "0x0a44986b70527154e9F4290eC14e5f0D1C861822",
    },
    observed_pub_key: {
      example:
        "thorpub1addwnpepq27ck6u44zl8qqdnmzjjc8rg72amrxrsp42p9vd7kt6marhy6ww76z8shwe",
      type: "string",
    },
    external_observed_height: {
      type: "integer",
      format: "int64",
      example: 7581334,
      description:
        "the block height on the external source chain when the transaction was observed, not provided if chain is THOR",
    },
    external_confirmation_delay_height: {
      description:
        "the block height on the external source chain when confirmation counting will be complete, not provided if chain is THOR",
      type: "integer",
      format: "int64",
      example: 7581334,
    },
  },
  type: "object",
} as const;

export const UpgradeVoteSchema = {
  type: "object",
  required: ["height", "node_address", "vote"],
  properties: {
    node_address: {
      type: "string",
      example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
      description: "the node address of the voter",
    },
    vote: {
      example: "approve",
      description: "the vote cast by the node",
      type: "string",
      enum: ["approve", "reject"],
    },
  },
} as const;

export const RUNEProviderResponseSchema = {
  $ref: "#/components/schemas/RUNEProvider",
} as const;

export const TxSchema = {
  type: "object",
  required: ["coins", "gas"],
  properties: {
    coins: {
      items: {
        $ref: "#/components/schemas/Coin",
      },
      type: "array",
    },
    gas: {
      items: {
        $ref: "#/components/schemas/Coin",
      },
      type: "array",
    },
    memo: {
      example: "ADD:BTC.BTC:thor1zupk5lmc84r2dh738a9g3zscavannjy3nzplwt",
      type: "string",
    },
    id: {
      example:
        "CF524818D42B63D25BBA0CCC4909F127CAA645C0F9CD07324F2824CC151A64C7",
      type: "string",
    },
    chain: {
      type: "string",
      example: "BTC",
    },
    from_address: {
      type: "string",
      example: "bcrt1q0s4mg25tu6termrk8egltfyme4q7sg3h8kkydt",
    },
    to_address: {
      type: "string",
      example: "bcrt1qf3s7q037eancht7sg0aj995dht25rwrnqsf45e",
    },
  },
} as const;

export const TssKeysignMetricSchema = {
  type: "object",
  required: ["node_tss_times"],
  properties: {
    tx_id: {
      type: "string",
    },
    node_tss_times: {
      type: "array",
      items: {
        $ref: "#/components/schemas/TssMetric",
      },
    },
  },
} as const;

export const DerivedPoolResponseSchema = {
  $ref: "#/components/schemas/DerivedPool",
} as const;

export const TxDetailsResponseSchema = {
  type: "object",
  required: ["tx", "txs", "actions", "out_txs"],
  properties: {
    actions: {
      items: {
        $ref: "#/components/schemas/TxOutItem",
      },
      type: "array",
    },
    out_txs: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Tx",
      },
    },
    consensus_height: {
      example: 7581321,
      description:
        "the thorchain height at which the inbound reached consensus",
      type: "integer",
      format: "int64",
    },
    updated_vault: {
      example: false,
      type: "boolean",
    },
    outbound_height: {
      type: "integer",
      format: "int64",
      example: 1234,
      description: "the thorchain height for which the outbound was scheduled",
    },
    tx_id: {
      type: "string",
      example:
        "CF524818D42B63D25BBA0CCC4909F127CAA645C0F9CD07324F2824CC151A64C7",
    },
    tx: {
      $ref: "#/components/schemas/ObservedTx",
    },
    txs: {
      items: {
        $ref: "#/components/schemas/ObservedTx",
      },
      type: "array",
    },
    finalised_height: {
      type: "integer",
      format: "int64",
      example: 7581334,
      description: "the thorchain height at which the outbound was finalised",
    },
    reverted: {
      type: "boolean",
      example: false,
    },
  },
} as const;

export const POLSchema = {
  properties: {
    rune_deposited: {
      type: "string",
      example: "857134475040",
      description: "total amount of RUNE deposited into the pools",
    },
    rune_withdrawn: {
      type: "string",
      example: "0",
      description: "total amount of RUNE withdrawn from the pools",
    },
    value: {
      example: "21999180112172346",
      description: "total value of protocol's LP position in RUNE value",
      type: "string",
    },
    pnl: {
      type: "string",
      example: "21999180112172346",
      description: "profit and loss of protocol owned liquidity",
    },
    current_deposit: {
      type: "string",
      example: "21999180112172346",
      description: "current amount of rune deposited",
    },
  },
  type: "object",
  required: [
    "rune_deposited",
    "rune_withdrawn",
    "value",
    "pnl",
    "current_deposit",
  ],
} as const;

export const LiquidityProviderSummarySchema = {
  type: "object",
  required: [
    "asset",
    "units",
    "pending_rune",
    "pending_asset",
    "rune_deposit_value",
    "asset_deposit_value",
  ],
  properties: {
    last_withdraw_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    units: {
      type: "string",
      example: "0",
    },
    pending_rune: {
      type: "string",
      example: "0",
    },
    asset_deposit_value: {
      type: "string",
      example: "0",
    },
    asset: {
      example: "BTC.BTC",
      type: "string",
    },
    rune_address: {
      type: "string",
      example: "thor1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    },
    pending_asset: {
      type: "string",
      example: "242000000",
    },
    pending_tx_id: {
      type: "string",
      example:
        "C4C876802xxxxxxxxxxBC408829878446A37011EBBA0C5CAA3DD64A548879CB228",
    },
    rune_deposit_value: {
      type: "string",
      example: "0",
    },
    asset_address: {
      type: "string",
      example: "bc1qn9esxuw8ca7ts8l6w66kdh800s09msvutydc46",
    },
    last_add_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
  },
} as const;

export const SaverSchema = {
  required: [
    "asset",
    "asset_address",
    "units",
    "asset_deposit_value",
    "asset_redeem_value",
    "growth_pct",
  ],
  properties: {
    last_add_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    last_withdraw_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    units: {
      type: "string",
      example: "0",
    },
    asset_deposit_value: {
      type: "string",
      example: "0",
    },
    asset_redeem_value: {
      type: "string",
      example: "0",
    },
    growth_pct: {
      type: "string",
      example: "0.02",
    },
    asset: {
      type: "string",
      example: "BTC.BTC",
    },
    asset_address: {
      example: "bc1qn9esxuw8ca7ts8l6w66kdh800s09msvutydc46",
      type: "string",
    },
  },
  type: "object",
} as const;

export const StreamingSwapSchema = {
  type: "object",
  required: ["trade_target", "deposit", "in", "out"],
  properties: {
    source_asset: {
      type: "string",
      example: "BTC.BTC",
      description: "the asset to be swapped from",
    },
    failed_swaps: {
      items: {
        type: "integer",
        format: "int64",
      },
      type: "array",
      description: "the list of swap indexes that failed",
    },
    quantity: {
      type: "integer",
      format: "int64",
      description: "the total number of swaps in a streaming swaps",
    },
    last_height: {
      format: "int64",
      description: "the block height of the latest swap",
      type: "integer",
    },
    trade_target: {
      description:
        "the total number of tokens the swapper wants to receive of the output asset",
      type: "string",
      example: "100",
    },
    failed_swap_reasons: {
      description: "the list of reasons that sub-swaps have failed",
      items: {
        type: "string",
      },
      type: "array",
    },
    interval: {
      format: "int64",
      description: "how often each swap is made, in blocks",
      type: "integer",
    },
    destination: {
      description: "the destination address to receive the swap output",
      type: "string",
      example: "0x66fb1cd65b97fa40457b90b7d1ca6b92cb64b32b",
    },
    target_asset: {
      type: "string",
      example: "ETH.ETH",
      description: "the asset to be swapped to",
    },
    deposit: {
      type: "string",
      example: "100",
      description: "the number of input tokens the swapper has deposited",
    },
    in: {
      example: "100",
      description: "the amount of input tokens that have been swapped so far",
      type: "string",
    },
    out: {
      type: "string",
      example: "100",
      description: "the amount of output tokens that have been swapped so far",
    },
    tx_id: {
      type: "string",
      example:
        "CF524818D42B63D25BBA0CCC4909F127CAA645C0F9CD07324F2824CC151A64C7",
      description: "the hash of a transaction",
    },
    count: {
      type: "integer",
      format: "int64",
      description: "the amount of swap attempts so far",
    },
  },
} as const;

export const TxStatusResponseSchema = {
  type: "object",
  required: ["stages"],
  properties: {
    tx: {
      $ref: "#/components/schemas/Tx",
    },
    planned_out_txs: {
      type: "array",
      items: {
        type: "object",
        title: "PlannedOutTx",
        required: ["chain", "to_address", "coin", "refund"],
        properties: {
          chain: {
            type: "string",
            example: "BTC",
          },
          to_address: {
            type: "string",
            example: "bcrt1qf3s7q037eancht7sg0aj995dht25rwrnqsf45e",
          },
          coin: {
            $ref: "#/components/schemas/Coin",
          },
          refund: {
            type: "boolean",
            example: false,
            description:
              "returns true if the planned transaction has a refund memo",
          },
        },
      },
    },
    out_txs: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Tx",
      },
    },
    stages: {
      $ref: "#/components/schemas/TxStagesResponse",
    },
  },
} as const;

export const VaultResponseSchema = {
  $ref: "#/components/schemas/Vault",
} as const;

export const StreamingSwapResponseSchema = {
  $ref: "#/components/schemas/StreamingSwap",
} as const;

export const UpgradeProposalsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/UpgradeProposal",
  },
} as const;

export const QueueResponseSchema = {
  type: "object",
  required: [
    "swap",
    "outbound",
    "internal",
    "scheduled_outbound_value",
    "scheduled_outbound_clout",
  ],
  properties: {
    swap: {
      type: "integer",
      format: "int64",
      example: 0,
    },
    outbound: {
      type: "integer",
      format: "int64",
      example: 10,
      description: "number of signed outbound tx in the queue",
    },
    internal: {
      format: "int64",
      example: 0,
      type: "integer",
    },
    scheduled_outbound_value: {
      type: "string",
      description: "scheduled outbound value in RUNE",
    },
    scheduled_outbound_clout: {
      type: "string",
      description: "scheduled outbound clout in RUNE",
    },
  },
} as const;

export const MetricsResponseSchema = {
  type: "object",
  properties: {
    keygen: {
      $ref: "#/components/schemas/KeygenMetricsResponse",
    },
    keysign: {
      type: "object",
      title: "KeysignMetrics",
      properties: {
        tx_id: {
          type: "string",
        },
        node_tss_times: {
          items: {
            $ref: "#/components/schemas/TssMetric",
          },
          type: "array",
        },
      },
    },
  },
} as const;

export const VaultRouterSchema = {
  type: "object",
  properties: {
    router: {
      type: "string",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
    },
    chain: {
      type: "string",
      example: "ETH",
    },
  },
} as const;

export const OutboundFeeSchema = {
  type: "object",
  required: ["asset", "outbound_fee"],
  properties: {
    asset: {
      description: "the asset to display the outbound fee for",
      type: "string",
      example: "ETH.ETH",
    },
    outbound_fee: {
      type: "string",
      example: "300000",
      description:
        "the asset's outbound fee, in (1e8-format) units of the asset",
    },
    fee_withheld_rune: {
      type: "string",
      example: "30000000000000",
      description:
        "Total RUNE the network has withheld as fees to later cover gas costs for this asset's outbounds",
    },
    fee_spent_rune: {
      type: "string",
      example: "20000000000000",
      description:
        "Total RUNE the network has spent to reimburse gas costs for this asset's outbounds",
    },
    surplus_rune: {
      example: "10000000000000",
      description:
        "amount of RUNE by which the fee_withheld_rune exceeds the fee_spent_rune",
      type: "string",
    },
    dynamic_multiplier_basis_points: {
      type: "string",
      example: "15000",
      description:
        "dynamic multiplier basis points, based on the surplus_rune, affecting the size of the outbound_fee",
    },
  },
} as const;

export const QuoteFeesSchema = {
  type: "object",
  required: ["asset", "liquidity", "total", "slippage_bps", "total_bps"],
  properties: {
    slippage_bps: {
      type: "integer",
      format: "int64",
      description: "the swap slippage in basis points",
    },
    total_bps: {
      type: "integer",
      format: "int64",
      description: "total basis points in fees relative to amount out",
    },
    asset: {
      type: "string",
      example: "ETH.ETH",
      description: "the target asset used for all fees",
    },
    affiliate: {
      example: "1234",
      description: "affiliate fee in the target asset",
      type: "string",
    },
    outbound: {
      type: "string",
      example: "1234",
      description: "outbound fee in the target asset",
    },
    liquidity: {
      example: "1234",
      description: "liquidity fees paid to pools in the target asset",
      type: "string",
    },
    total: {
      type: "string",
      example: "9876",
      description: "total fees in the target asset",
    },
  },
} as const;

export const NodeResponseSchema = {
  $ref: "#/components/schemas/Node",
} as const;

export const InvariantResponseSchema = {
  properties: {
    invariant: {
      type: "string",
      example: "asgard",
      description: "The name of the invariant.",
    },
    broken: {
      type: "boolean",
      example: false,
      description: "Returns true if the invariant is broken.",
    },
    msg: {
      type: "array",
      items: {
        type: "string",
      },
      example: ["insolvent: 200000rune", "oversolvent: 1btc/btc"],
      description: "Informative message about the invariant result.",
    },
  },
  type: "object",
  required: ["invariant", "broken", "msg"],
} as const;

export const BanResponseSchema = {
  type: "object",
  properties: {
    node_address: {
      type: "string",
      example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
    },
    block_height: {
      type: "integer",
      format: "int64",
    },
    signers: {
      type: "array",
      items: {
        type: "string",
        example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
      },
    },
  },
} as const;

export const OutboundResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/TxOutItem",
  },
} as const;

export const BlockResponseSchema = {
  required: ["id", "header", "begin_block_events", "end_block_events", "txs"],
  properties: {
    header: {
      type: "object",
      required: [
        "version",
        "chain_id",
        "height",
        "time",
        "last_block_id",
        "last_commit_hash",
        "data_hash",
        "validators_hash",
        "next_validators_hash",
        "consensus_hash",
        "app_hash",
        "last_results_hash",
        "evidence_hash",
        "proposer_address",
      ],
      properties: {
        chain_id: {
          type: "string",
          example: "cosmoshub-2",
        },
        last_commit_hash: {
          type: "string",
          example:
            "21B9BC845AD2CB2C4193CDD17BFC506F1EBE5A7402E84AD96E64171287A34812",
        },
        last_results_hash: {
          type: "string",
          example: "",
        },
        version: {
          type: "object",
          required: ["block", "app"],
          properties: {
            block: {
              type: "string",
              example: "10",
            },
            app: {
              type: "string",
              example: "0",
            },
          },
        },
        height: {
          type: "integer",
          format: "int64",
          example: 123,
        },
        time: {
          type: "string",
          example: "2019-04-22T17:01:51.701356223Z",
        },
        validators_hash: {
          type: "string",
          example:
            "D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0",
        },
        next_validators_hash: {
          type: "string",
          example:
            "D658BFD100CA8025CFD3BECFE86194322731D387286FBD26E059115FD5F2BCA0",
        },
        data_hash: {
          type: "string",
          example:
            "970886F99E77ED0D60DA8FCE0447C2676E59F2F77302B0C4AA10E1D02F18EF73",
        },
        consensus_hash: {
          type: "string",
          example:
            "0F2908883A105C793B74495EB7D6DF2EEA479ED7FC9349206A65CB0F9987A0B8",
        },
        app_hash: {
          type: "string",
          example:
            "223BF64D4A01074DC523A80E76B9BBC786C791FB0A1893AC5B14866356FCFD6C",
        },
        last_block_id: {
          type: "object",
          required: ["hash", "parts"],
          properties: {
            hash: {
              type: "string",
              example:
                "112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7",
            },
            parts: {
              type: "object",
              required: ["total", "hash"],
              properties: {
                total: {
                  type: "integer",
                  format: "int64",
                  example: 1,
                },
                hash: {
                  type: "string",
                  example:
                    "38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD",
                },
              },
            },
          },
        },
        evidence_hash: {
          type: "string",
          example: "",
        },
        proposer_address: {
          type: "string",
          example: "D540AB022088612AC74B287D076DBFBC4A377A2E",
        },
      },
    },
    begin_block_events: {
      type: "array",
      items: {
        type: "object",
        additionalProperties: {
          type: "string",
        },
      },
    },
    end_block_events: {
      type: "array",
      items: {
        type: "object",
        additionalProperties: {
          type: "string",
        },
      },
    },
    txs: {
      type: "array",
      nullable: true,
      items: {
        $ref: "#/components/schemas/BlockTx",
      },
    },
    id: {
      type: "object",
      required: ["hash", "parts"],
      properties: {
        hash: {
          type: "string",
          example:
            "112BC173FD838FB68EB43476816CD7B4C6661B6884A9E357B417EE957E1CF8F7",
        },
        parts: {
          type: "object",
          required: ["total", "hash"],
          properties: {
            total: {
              type: "integer",
              format: "int64",
              example: 1,
            },
            hash: {
              type: "string",
              example:
                "38D4B26B5B725C4F13571EFE022C030390E4C33C8CF6F88EDD142EA769642DBD",
            },
          },
        },
      },
    },
  },
  type: "object",
} as const;

export const LiquidityProviderSchema = {
  type: "object",
  required: [
    "asset",
    "units",
    "pending_rune",
    "pending_asset",
    "rune_deposit_value",
    "asset_deposit_value",
  ],
  properties: {
    rune_redeem_value: {
      type: "string",
      example: "0",
    },
    asset_redeem_value: {
      type: "string",
      example: "0",
    },
    luvi_deposit_value: {
      type: "string",
      example: "0",
    },
    asset: {
      type: "string",
      example: "BTC.BTC",
    },
    rune_address: {
      type: "string",
      example: "thor1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
    },
    last_add_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    pending_rune: {
      type: "string",
      example: "0",
    },
    asset_address: {
      type: "string",
      example: "bc1qn9esxuw8ca7ts8l6w66kdh800s09msvutydc46",
    },
    units: {
      type: "string",
      example: "0",
    },
    asset_deposit_value: {
      example: "0",
      type: "string",
    },
    luvi_redeem_value: {
      type: "string",
      example: "0",
    },
    luvi_growth_pct: {
      type: "string",
      example: "0",
    },
    last_withdraw_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    pending_asset: {
      type: "string",
      example: "242000000",
    },
    pending_tx_id: {
      type: "string",
      example:
        "C4C876802xxxxxxxxxxBC408829878446A37011EBBA0C5CAA3DD64A548879CB228",
    },
    rune_deposit_value: {
      type: "string",
      example: "0",
    },
  },
} as const;

export const PoolResponseSchema = {
  $ref: "#/components/schemas/Pool",
} as const;

export const InboundAddressesResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/InboundAddress",
  },
} as const;

export const UpgradeProposalResponseSchema = {
  $ref: "#/components/schemas/UpgradeProposal",
} as const;

export const SaverResponseSchema = {
  $ref: "#/components/schemas/Saver",
} as const;

export const VaultPubkeysResponseSchema = {
  type: "object",
  required: ["asgard", "yggdrasil", "inactive"],
  properties: {
    asgard: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultInfo",
      },
    },
    yggdrasil: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultInfo",
      },
    },
    inactive: {
      type: "array",
      items: {
        $ref: "#/components/schemas/VaultInfo",
      },
    },
  },
} as const;

export const OutboundFeesResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/OutboundFee",
  },
} as const;

export const MimirNodesResponseSchema = {
  type: "object",
  properties: {
    mimirs: {
      items: {
        type: "object",
        title: "MimirVote",
        properties: {
          signer: {
            type: "string",
          },
          key: {
            type: "string",
          },
          value: {
            type: "integer",
            format: "int64",
          },
        },
      },
      type: "array",
    },
  },
} as const;

export const RUNEProviderSchema = {
  type: "object",
  required: [
    "rune_address",
    "units",
    "value",
    "pnl",
    "deposit_amount",
    "withdraw_amount",
    "last_deposit_height",
    "last_withdraw_height",
  ],
  properties: {
    rune_address: {
      type: "string",
      example: "THOR.RUNE",
    },
    units: {
      example: "1234",
      type: "string",
    },
    value: {
      type: "string",
      example: "123456",
    },
    pnl: {
      type: "string",
      example: "123456",
    },
    deposit_amount: {
      type: "string",
      example: "6677",
    },
    withdraw_amount: {
      type: "string",
      example: "5443",
    },
    last_deposit_height: {
      type: "integer",
      format: "int64",
      example: 82745,
    },
    last_withdraw_height: {
      format: "int64",
      example: 82745,
      type: "integer",
    },
  },
} as const;

export const InboundAddressSchema = {
  type: "object",
  required: ["halted"],
  properties: {
    gas_rate: {
      type: "string",
      example: "214",
      description:
        "The minimum fee rate used by vaults to send outbound TXs. The actual fee rate may be higher. For EVM chains this is returned in gwei (1e9).",
    },
    outbound_fee: {
      type: "string",
      example: "428000",
      description:
        "The total outbound fee charged to the user for outbound txs in the gas asset of the chain.",
    },
    address: {
      type: "string",
      example: "bc1qn9esxuw8ca7ts8l6w66kdh800s09msvutydc46",
    },
    router: {
      type: "string",
      example: "0xD37BbE5744D730a1d98d8DC97c42F0Ca46aD7146",
    },
    halted: {
      type: "boolean",
      example: false,
      description:
        "Returns true if trading is unavailable for this chain, either because trading is halted globally or specifically for this chain",
    },
    global_trading_paused: {
      example: false,
      description: "Returns true if trading is paused globally",
      type: "boolean",
    },
    chain_trading_paused: {
      type: "boolean",
      example: false,
      description: "Returns true if trading is paused for this chain",
    },
    dust_threshold: {
      type: "string",
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
    },
    chain: {
      example: "BTC",
      type: "string",
    },
    pub_key: {
      type: "string",
      example:
        "thorpub1addwnpepq2jqhv5rdqlkusfxy05stfzcgslhhz5qh8pxetw5ry2aa6awgdh3shq8s82",
    },
    chain_lp_actions_paused: {
      type: "boolean",
      example: false,
      description: "Returns true if LP actions are paused for this chain",
    },
    gas_rate_units: {
      type: "string",
      example: "satsperbyte",
      description: "Units of the gas_rate.",
    },
    outbound_tx_size: {
      description:
        "Avg size of outbound TXs on each chain. For UTXO chains it may be larger than average, as it takes into account vault consolidation txs, which can have many vouts",
      type: "string",
      example: "1000",
    },
  },
} as const;

export const UpgradeProposalSchema = {
  type: "object",
  required: ["name", "height", "info"],
  properties: {
    approved_percent: {
      type: "string",
      example: "0.8",
      description:
        "the percentage of active validators that have approved the upgrade",
    },
    validators_to_quorum: {
      type: "integer",
      format: "int64",
      example: 20,
      description:
        "the amount of additional active validators required to reach quorum for the upgrade",
    },
    name: {
      type: "string",
      example: "scheduled upgrade 1",
      description: "the name of the upgrade",
    },
    height: {
      type: "integer",
      format: "int64",
      example: 1234,
      description: "the block height at which the upgrade will occur",
    },
    info: {
      example:
        '{"binaries":{"linux/amd64":"https://link.to.binary.amd64","linux/arm64":"https://link.to.binary.arm64"}}',
      description:
        "the description of the upgrade, typically json with URLs to binaries for use with automation tools",
      type: "string",
    },
    approved: {
      type: "boolean",
      example: true,
      description:
        "whether the upgrade has been approved by the active validators",
    },
  },
} as const;

export const LiquidityProvidersResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/LiquidityProviderSummary",
  },
} as const;

export const QuoteSwapResponseSchema = {
  type: "object",
  required: [
    "expected_amount_out",
    "outbound_delay_blocks",
    "outbound_delay_seconds",
    "fees",
    "warning",
    "notes",
    "expiry",
  ],
  properties: {
    expected_amount_out: {
      description:
        "the amount of the target asset the user can expect to receive after fees",
      example: "10000",
      type: "string",
    },
    inbound_confirmation_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the approximate number of source chain blocks required before processing",
    },
    fees: {
      $ref: "#/components/schemas/QuoteFees",
    },
    expiry: {
      type: "integer",
      format: "int64",
      description: "expiration timestamp in unix seconds",
      example: 1671660285,
    },
    notes: {
      type: "string",
      description: "chain specific quote notes",
      example:
        "Transfer the inbound_address the asset with the memo. Do not use multi-in, multi-out transactions.",
    },
    dust_threshold: {
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
      type: "string",
    },
    gas_rate_units: {
      type: "string",
      example: "gwei",
      description: "the units of the recommended gas rate",
    },
    max_streaming_quantity: {
      type: "integer",
      format: "int64",
      description:
        "the maximum amount of trades a streaming swap can do for a trade",
      example: 10,
    },
    total_swap_seconds: {
      type: "integer",
      format: "int64",
      description:
        "total number of seconds a swap is expected to take (inbound conf + streaming swap + outbound delay)",
      example: 600,
    },
    inbound_address: {
      description:
        "the inbound address for the transaction on the source chain",
      example: "bc1qjk3xzu5slu7mtmc8jc9yed3zqvkhkttm700g9a",
      type: "string",
    },
    inbound_confirmation_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for block confirmations required before processing",
    },
    outbound_delay_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the number of thorchain blocks the outbound will be delayed",
    },
    memo: {
      description: "generated memo for the swap",
      example:
        "=:ETH.ETH:0x1c7b17362c84287bd1184447e6dfeaf920c31bbe:1440450000:thor17gw75axcnr8747pkanye45pnrwk7p9c3cqncsv:100",
      type: "string",
    },
    streaming_swap_seconds: {
      type: "integer",
      format: "int64",
      description:
        "approx the number of seconds the streaming swap will execute over",
      example: 600,
    },
    streaming_swap_blocks: {
      type: "integer",
      format: "int64",
      description: "the number of blocks the streaming swap will execute over",
      example: 100,
    },
    outbound_delay_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for the outbound delay before it will be sent",
    },
    router: {
      type: "string",
      description: "the EVM chain router contract address",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
    },
    warning: {
      type: "string",
      description: "static warning message",
      example:
        "Do not cache this response. Do not send funds after the expiry.",
    },
    recommended_min_amount_in: {
      description:
        "The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.",
      example: "15000",
      type: "string",
    },
    recommended_gas_rate: {
      example: "10",
      description:
        "the recommended gas rate to use for the inbound to ensure timely confirmation",
      type: "string",
    },
  },
} as const;

export const InvariantsResponseSchema = {
  type: "object",
  properties: {
    invariants: {
      type: "array",
      items: {
        type: "string",
      },
    },
  },
} as const;

export const LastBlockSchema = {
  type: "object",
  required: ["chain", "last_observed_in", "last_signed_out", "thorchain"],
  properties: {
    chain: {
      type: "string",
    },
    last_observed_in: {
      format: "int64",
      type: "integer",
    },
    last_signed_out: {
      format: "int64",
      type: "integer",
    },
    thorchain: {
      type: "integer",
      format: "int64",
    },
  },
} as const;

export const NodeSchema = {
  type: "object",
  required: [
    "node_address",
    "status",
    "pub_key_set",
    "validator_cons_pub_key",
    "peer_id",
    "active_block_height",
    "status_since",
    "node_operator_address",
    "total_bond",
    "bond_providers",
    "signer_membership",
    "requested_to_leave",
    "forced_to_leave",
    "leave_height",
    "ip_address",
    "version",
    "slash_points",
    "jail",
    "current_award",
    "observe_chains",
    "preflight_status",
  ],
  properties: {
    node_address: {
      type: "string",
      example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
    },
    peer_id: {
      type: "string",
      description: "the P2PID (:6040/p2pid endpoint) of the node",
      example: "16Uiu2HAmRgsiryer3pWCPJz18PQZDFFs1GBqCPGGJczrQXdoTBMk",
    },
    total_bond: {
      type: "string",
      description: "current node bond",
      example: "123456789",
    },
    current_award: {
      type: "string",
      example: "123456",
    },
    node_operator_address: {
      type: "string",
      example: "thor1f3s7q037eancht7sg0aj995dht25rwrnu4ats5",
    },
    version: {
      type: "string",
      description: "the currently set version of the node",
      example: "0.35.0",
    },
    observe_chains: {
      type: "array",
      description: "the last observed heights for all chain by the node",
      items: {
        type: "object",
        title: "ChainHeight",
        required: ["chain", "height"],
        properties: {
          chain: {
            type: "string",
            example: "BTC",
          },
          height: {
            type: "integer",
            format: "int64",
            example: 2000000,
          },
        },
      },
    },
    active_block_height: {
      format: "int64",
      description: "the block height at which the node became active",
      example: 123456,
      type: "integer",
    },
    signer_membership: {
      description: "the set of vault public keys of which the node is a member",
      items: {
        type: "string",
        example:
          "thorpub1addwnpepq2jqhv5rdqlkusfxy05stfzcgslhhz5qh8pxetw5ry2aa6awgdh3shq8s82",
      },
      type: "array",
    },
    requested_to_leave: {
      type: "boolean",
    },
    forced_to_leave: {
      type: "boolean",
      description:
        "indicates whether the node has been forced to leave by the network, typically via ban",
    },
    leave_height: {
      example: 0,
      type: "integer",
      format: "int64",
    },
    ip_address: {
      example: "10.20.30.40",
      type: "string",
    },
    jail: {
      type: "object",
      title: "NodeJail",
      properties: {
        release_height: {
          type: "integer",
          format: "int64",
          example: 1234,
        },
        reason: {
          type: "string",
        },
      },
    },
    status: {
      type: "string",
      enum: ["Active", "Whitelisted", "Standby", "Disabled"],
      example: "Active",
    },
    pub_key_set: {
      type: "object",
      title: "NodePubKeySet",
      properties: {
        secp256k1: {
          type: "string",
          example:
            "thorpub1addwnpepq27ck6u44zl8qqdnmzjjc8rg72amrxrsp42p9vd7kt6marhy6ww76z8shwe",
        },
        ed25519: {
          type: "string",
          example:
            "thorpub1addwnpepq27ck6u44zl8qqdnmzjjc8rg72amrxrsp42p9vd7kt6marhy6ww76z8shwe",
        },
      },
    },
    validator_cons_pub_key: {
      example: "thor104gsqwta048e80j909g6y9kkqdjrw0lff866ew",
      type: "string",
      description: "the consensus pub key for the node",
    },
    status_since: {
      example: 100000,
      type: "integer",
      format: "int64",
      description:
        "the block height of the current provided information for the node",
    },
    bond_providers: {
      title: "NodeBondProviders",
      required: ["node_operator_fee", "providers"],
      properties: {
        node_operator_fee: {
          type: "string",
          description: "node operator fee in basis points",
        },
        providers: {
          type: "array",
          description: "all the bond providers for the node",
          items: {
            properties: {
              bond_address: {
                type: "string",
              },
              bond: {
                type: "string",
              },
            },
            type: "object",
            title: "NodeBondProvider",
          },
        },
      },
      type: "object",
    },
    slash_points: {
      type: "integer",
      format: "int64",
      description:
        "the accumulated slash points, reset at churn but excessive slash points may carry over",
      example: 42,
    },
    preflight_status: {
      type: "object",
      title: "NodePreflightStatus",
      required: ["status", "reason", "code"],
      properties: {
        status: {
          type: "string",
          description: "the next status of the node",
          example: "Ready",
        },
        reason: {
          type: "string",
          description: "the reason for the transition to the next status",
          example: "OK",
        },
        code: {
          type: "integer",
          format: "int64",
          example: 0,
        },
      },
    },
  },
} as const;

export const TxStagesResponseSchema = {
  type: "object",
  required: ["inbound_observed"],
  properties: {
    inbound_finalised: {
      required: ["completed"],
      properties: {
        completed: {
          example: false,
          description:
            "returns true if the inbound transaction has been finalised (THORChain agreeing it exists)",
          type: "boolean",
        },
      },
      type: "object",
      title: "InboundFinalisedStage",
    },
    swap_status: {
      properties: {
        pending: {
          type: "boolean",
          example: false,
          description: "true when awaiting a swap",
        },
        streaming: {
          required: ["interval", "quantity", "count"],
          properties: {
            interval: {
              type: "integer",
              format: "int64",
              description: "how often each swap is made, in blocks",
            },
            quantity: {
              type: "integer",
              format: "int64",
              description: "the total number of swaps in a streaming swaps",
            },
            count: {
              type: "integer",
              format: "int64",
              description: "the amount of swap attempts so far",
            },
          },
          type: "object",
          title: "StreamingStatus",
        },
      },
      type: "object",
      title: "SwapStatus",
      required: ["pending"],
    },
    swap_finalised: {
      type: "object",
      title: "SwapFinalisedStage",
      required: ["completed"],
      properties: {
        completed: {
          type: "boolean",
          example: false,
          description:
            "(to be deprecated in favor of swap_status) returns true if an inbound transaction's swap (successful or refunded) is no longer pending",
        },
      },
    },
    outbound_delay: {
      type: "object",
      title: "OutboundDelayStage",
      required: ["completed"],
      properties: {
        remaining_delay_blocks: {
          type: "integer",
          format: "int64",
          example: 5,
          description:
            "the number of remaining THORChain blocks the outbound will be delayed",
        },
        remaining_delay_seconds: {
          type: "integer",
          format: "int64",
          example: 30,
          description:
            "the estimated remaining seconds of the outbound delay before it will be sent",
        },
        completed: {
          type: "boolean",
          example: false,
          description: "returns true if no transaction outbound delay remains",
        },
      },
    },
    outbound_signed: {
      type: "object",
      title: "OutboundSignedStage",
      required: ["completed"],
      properties: {
        scheduled_outbound_height: {
          example: 1234,
          description:
            "THORChain height for which the external outbound is scheduled",
          type: "integer",
          format: "int64",
        },
        blocks_since_scheduled: {
          type: "integer",
          format: "int64",
          example: 1234,
          description: "THORChain blocks since the scheduled outbound height",
        },
        completed: {
          type: "boolean",
          example: false,
          description:
            "returns true if an external transaction has been signed and broadcast (and observed in its mempool)",
        },
      },
    },
    inbound_observed: {
      type: "object",
      title: "InboundObservedStage",
      required: ["final_count", "completed"],
      properties: {
        final_count: {
          example: 80,
          description:
            "number of signers for final observations, after any confirmation counting complete",
          type: "integer",
          format: "int64",
        },
        completed: {
          type: "boolean",
          example: false,
          description:
            "returns true if no transaction observation remains to be done",
        },
        started: {
          type: "boolean",
          example: false,
          description:
            "returns true if any nodes have observed the transaction (to be deprecated in favour of counts)",
        },
        pre_confirmation_count: {
          type: "integer",
          format: "int64",
          example: 80,
          description:
            "number of signers for pre-confirmation-counting observations",
        },
      },
    },
    inbound_confirmation_counted: {
      type: "object",
      title: "InboundConfirmationCountedStage",
      required: ["completed"],
      properties: {
        chain: {
          type: "string",
          example: "BTC",
          description:
            "the external source chain for which confirmation counting takes place",
        },
        external_observed_height: {
          type: "integer",
          format: "int64",
          example: 16042625,
          description:
            "the block height on the external source chain when the transaction was observed",
        },
        external_confirmation_delay_height: {
          description:
            "the block height on the external source chain when confirmation counting will be complete",
          type: "integer",
          format: "int64",
          example: 16042626,
        },
        remaining_confirmation_seconds: {
          description:
            "the estimated remaining seconds before confirmation counting completes",
          type: "integer",
          format: "int64",
          example: 600,
        },
        completed: {
          type: "boolean",
          example: false,
          description:
            "returns true if no transaction confirmation counting remains to be done",
        },
        counting_start_height: {
          type: "integer",
          format: "int64",
          example: 1234,
          description:
            "the THORChain block height when confirmation counting began",
        },
      },
    },
  },
} as const;

export const YggdrasilVaultsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/YggdrasilVault",
  },
} as const;

export const TradeUnitResponseSchema = {
  type: "object",
  required: ["asset", "units", "depth"],
  properties: {
    units: {
      type: "string",
      description: "total units of trade asset",
    },
    depth: {
      type: "string",
      description: "total depth of trade asset",
    },
    asset: {
      type: "string",
      example: "BTC~BTC",
      description: 'trade account asset with "~" separator',
    },
  },
} as const;

export const TradeUnitsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/TradeUnitResponse",
  },
} as const;

export const TradeAccountsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/TradeAccountResponse",
  },
} as const;

export const TxSignersResponseSchema = {
  type: "object",
  required: ["tx", "txs", "actions", "out_txs"],
  properties: {
    out_txs: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Tx",
      },
    },
    finalised_height: {
      type: "integer",
      format: "int64",
      example: 7581334,
      description: "the thorchain height at which the outbound was finalised",
    },
    tx: {
      $ref: "#/components/schemas/ObservedTx",
    },
    txs: {
      type: "array",
      items: {
        $ref: "#/components/schemas/ObservedTx",
      },
    },
    actions: {
      type: "array",
      items: {
        $ref: "#/components/schemas/TxOutItem",
      },
    },
    consensus_height: {
      example: 7581321,
      description:
        "the thorchain height at which the inbound reached consensus",
      type: "integer",
      format: "int64",
    },
    updated_vault: {
      type: "boolean",
      example: false,
    },
    reverted: {
      example: false,
      type: "boolean",
    },
    outbound_height: {
      type: "integer",
      format: "int64",
      example: 1234,
      description: "the thorchain height for which the outbound was scheduled",
    },
    tx_id: {
      type: "string",
      example:
        "CF524818D42B63D25BBA0CCC4909F127CAA645C0F9CD07324F2824CC151A64C7",
    },
  },
} as const;

export const VaultsResponseSchema = {
  items: {
    $ref: "#/components/schemas/Vault",
  },
  type: "array",
} as const;

export const KeysignResponseSchema = {
  type: "object",
  required: ["keysign", "signature"],
  properties: {
    keysign: {
      required: ["tx_array"],
      properties: {
        height: {
          type: "integer",
          format: "int64",
          description:
            "the block(s) in which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue",
        },
        tx_array: {
          type: "array",
          items: {
            $ref: "#/components/schemas/TxOutItem",
          },
        },
      },
      type: "object",
      title: "KeysignInfo",
    },
    signature: {
      type: "string",
    },
  },
} as const;

export const SwapperCloutResponseSchema = {
  type: "object",
  required: ["address"],
  properties: {
    address: {
      description: "address associated with this clout account",
      type: "string",
      example: "bc1....",
    },
    score: {
      type: "string",
      description:
        "clout score, which is the amount of rune spent on swap fees",
    },
    reclaimed: {
      type: "string",
      description:
        "amount of clout that has been reclaimed in total over time (observed clout spent)",
    },
    spent: {
      type: "string",
      description: "amount of clout that has been spent in total over time",
    },
    last_spent_height: {
      type: "integer",
      format: "int64",
      description: "last block height that clout was spent",
    },
    last_reclaim_height: {
      type: "integer",
      format: "int64",
      description: "last block height that clout was reclaimed",
    },
  },
} as const;

export const QuoteSaverDepositResponseSchema = {
  properties: {
    inbound_address: {
      type: "string",
      description:
        "the inbound address for the transaction on the source chain",
      example: "bc1qjk3xzu5slu7mtmc8jc9yed3zqvkhkttm700g9a",
    },
    outbound_delay_blocks: {
      description:
        "the number of thorchain blocks the outbound will be delayed",
      type: "integer",
      format: "int64",
    },
    expiry: {
      type: "integer",
      format: "int64",
      description: "expiration timestamp in unix seconds",
      example: 1671660285,
    },
    memo: {
      description: "generated memo for the deposit",
      example: "+:ETH/ETH::thor17gw75axcnr8747pkanye45pnrwk7p9c3cqncsv:100",
      type: "string",
    },
    router: {
      description: "the EVM chain router contract address",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
      type: "string",
    },
    warning: {
      description: "static warning message",
      example:
        "Do not cache this response. Do not send funds after the expiry.",
      type: "string",
    },
    recommended_min_amount_in: {
      type: "string",
      description:
        "The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.",
      example: "15000",
    },
    expected_amount_out: {
      type: "string",
      description:
        "same as expected_amount_deposit, to be deprecated in favour of expected_amount_deposit",
      example: "10000",
    },
    inbound_confirmation_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the approximate number of source chain blocks required before processing",
    },
    inbound_confirmation_seconds: {
      description:
        "the approximate seconds for block confirmations required before processing",
      type: "integer",
      format: "int64",
    },
    outbound_delay_seconds: {
      format: "int64",
      description:
        "the approximate seconds for the outbound delay before it will be sent",
      type: "integer",
    },
    fees: {
      $ref: "#/components/schemas/QuoteFees",
    },
    notes: {
      type: "string",
      description: "chain specific quote notes",
      example:
        "Transfer the inbound_address the asset with the memo. Do not use multi-in, multi-out transactions.",
    },
    dust_threshold: {
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
      type: "string",
    },
    expected_amount_deposit: {
      type: "string",
      description:
        "the amount of the target asset the user can expect to deposit after fees",
      example: "10000",
    },
    recommended_gas_rate: {
      type: "string",
      example: "10",
      description:
        "the recommended gas rate to use for the inbound to ensure timely confirmation",
    },
    gas_rate_units: {
      type: "string",
      example: "gwei",
      description: "the units of the recommended gas rate",
    },
  },
  type: "object",
  required: [
    "memo",
    "inbound_address",
    "expected_amount_deposit",
    "fees",
    "slippage_bps",
    "warning",
    "notes",
    "expiry",
    "recommended_gas_rate",
    "gas_rate_units",
  ],
} as const;

export const QuoteLoanCloseResponseSchema = {
  type: "object",
  required: [
    "expected_amount_out",
    "expected_collateral_withdrawn",
    "expected_debt_repaid",
    "expected_amount_in",
    "memo",
    "outbound_delay_blocks",
    "outbound_delay_seconds",
    "fees",
    "warning",
    "notes",
    "expiry",
    "streaming_swap_blocks",
    "streaming_swap_seconds",
    "total_repay_seconds",
  ],
  properties: {
    dust_threshold: {
      type: "string",
      example: "10000",
      description:
        "Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.",
    },
    recommended_gas_rate: {
      type: "string",
      example: "10",
      description:
        "the recommended gas rate to use for the inbound to ensure timely confirmation",
    },
    memo: {
      type: "string",
      description: "generated memo for the loan close",
      example: "$-:ETH.ETH:0x1c7b17362c84287bd1184447e6dfeaf920c31bbe",
    },
    expected_amount_out: {
      type: "string",
      description:
        "the amount of collateral asset the user can expect to receive after fees in 1e8 decimals",
      example: "10000",
    },
    streaming_swap_seconds: {
      type: "integer",
      format: "int64",
      description:
        "The approximate number of seconds taken by the streaming swaps involved in the repayment process.",
      example: 600,
    },
    total_repay_seconds: {
      type: "integer",
      format: "int64",
      description:
        "The total expected duration for a repayment, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.",
      example: 600,
    },
    notes: {
      type: "string",
      description: "chain specific quote notes",
      example:
        "Transfer the inbound_address the asset with the memo. Do not use multi-in, multi-out transactions.",
    },
    inbound_confirmation_seconds: {
      format: "int64",
      description:
        "the approximate seconds for block confirmations required before processing",
      type: "integer",
    },
    fees: {
      $ref: "#/components/schemas/QuoteFees",
    },
    recommended_min_amount_in: {
      type: "string",
      description:
        "The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.",
      example: "15000",
    },
    expected_amount_in: {
      description:
        "The quantity of the repayment asset to be sent by the user, calculated as the desired percentage of the loan's value, expressed in units of 1e8",
      example: "10000",
      type: "string",
    },
    inbound_confirmation_blocks: {
      type: "integer",
      format: "int64",
      description:
        "the approximate number of source chain blocks required before processing",
    },
    outbound_delay_seconds: {
      type: "integer",
      format: "int64",
      description:
        "the approximate seconds for the outbound delay before it will be sent",
    },
    router: {
      type: "string",
      description: "the EVM chain router contract address",
      example: "0x3624525075b88B24ecc29CE226b0CEc1fFcB6976",
    },
    expiry: {
      type: "integer",
      format: "int64",
      description: "expiration timestamp in unix seconds",
      example: 1671660285,
    },
    gas_rate_units: {
      type: "string",
      example: "gwei",
      description: "the units of the recommended gas rate",
    },
    expected_debt_repaid: {
      type: "string",
      description: "the expected amount of TOR debt decrease on the loan",
      example: "1000000",
    },
    outbound_delay_blocks: {
      description:
        "the number of thorchain blocks the outbound will be delayed",
      type: "integer",
      format: "int64",
    },
    warning: {
      type: "string",
      description: "static warning message",
      example:
        "Do not cache this response. Do not send funds after the expiry.",
    },
    expected_collateral_withdrawn: {
      type: "string",
      description: "the expected amount of collateral decrease on the loan",
      example: "1000000",
    },
    streaming_swap_blocks: {
      type: "integer",
      format: "int64",
      description:
        "The number of blocks involved in the streaming swaps during the repayment process.",
      example: 10,
    },
    inbound_address: {
      type: "string",
      description:
        "the inbound address for the transaction on the source chain",
      example: "bc1qjk3xzu5slu7mtmc8jc9yed3zqvkhkttm700g9a",
    },
  },
} as const;

export const ThornameAliasSchema = {
  type: "object",
  properties: {
    chain: {
      type: "string",
      example: "BTC",
    },
    address: {
      type: "string",
      example: "bc1qn9esxuw8ca7ts8l6w66kdh800s09msvutydc46",
    },
  },
} as const;

export const DerivedPoolsResponseSchema = {
  type: "array",
  items: {
    $ref: "#/components/schemas/DerivedPool",
  },
} as const;

export const NetworkResponseSchema = {
  required: [
    "bond_reward_rune",
    "total_bond_units",
    "effective_security_bond",
    "total_reserve",
    "vaults_migrating",
    "gas_spent_rune",
    "gas_withheld_rune",
    "native_outbound_fee_rune",
    "native_tx_fee_rune",
    "tns_register_fee_rune",
    "tns_fee_per_block_rune",
    "rune_price_in_tor",
    "tor_price_in_rune",
  ],
  properties: {
    rune_price_in_tor: {
      description: "the rune price in tor",
      type: "string",
      example: "10",
    },
    total_reserve: {
      type: "string",
      example: "21999180112172346",
      description: "total reserve RUNE",
    },
    gas_spent_rune: {
      type: "string",
      example: "1000000000",
      description: "Sum of the gas the network has spent to send outbounds",
    },
    outbound_fee_multiplier: {
      type: "string",
      example: "15000",
      description: "Current outbound fee multiplier, in basis points",
    },
    bond_reward_rune: {
      type: "string",
      example: "857134475040",
      description: "total amount of RUNE awarded to node operators",
    },
    total_bond_units: {
      type: "string",
      example: "0",
      description: "total bonded RUNE",
    },
    gas_withheld_rune: {
      type: "string",
      example: "1500000000",
      description: "Sum of the gas withheld from users to cover outbound gas",
    },
    tns_register_fee_rune: {
      type: "string",
      example: "1000000000",
      description:
        "the thorname register fee in rune, converted from the TNSRegisterFeeUSD mimir (after USD fees are enabled)",
    },
    tor_price_in_rune: {
      type: "string",
      example: "10",
      description: "the tor price in rune",
    },
    effective_security_bond: {
      type: "string",
      example: "0",
      description:
        "effective security bond used to determine maximum pooled RUNE",
    },
    vaults_migrating: {
      type: "boolean",
      example: false,
      description:
        "Returns true if there exist RetiringVaults which have not finished migrating funds to new ActiveVaults",
    },
    tns_fee_per_block_rune: {
      type: "string",
      example: "20",
      description:
        "the thorname fee per block in rune, converted from the TNSFeePerBlockUSD mimir (after USD fees are enabled)",
    },
    native_outbound_fee_rune: {
      type: "string",
      example: "100000000",
      description:
        "the outbound transaction fee in rune, converted from the NativeOutboundFeeUSD mimir (after USD fees are enabled)",
    },
    native_tx_fee_rune: {
      type: "string",
      example: "100000000",
      description:
        "the native transaction fee in rune, converted from the NativeTransactionFeeUSD mimir (after USD fees are enabled)",
    },
  },
  type: "object",
} as const;

export const KeygenMetricsResponseSchema = {
  items: {
    $ref: "#/components/schemas/KeygenMetric",
  },
  type: "array",
} as const;
