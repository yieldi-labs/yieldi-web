// This file is auto-generated by @hey-api/openapi-ts

export type BanResponse = {
    block_height?: number;
    node_address?: string;
    signers?: Array<(string)>;
};

export type BlockResponse = {
    begin_block_events: Array<{
        [key: string]: (string);
    }>;
    end_block_events: Array<{
        [key: string]: (string);
    }>;
    header: {
        app_hash: string;
        chain_id: string;
        consensus_hash: string;
        data_hash: string;
        evidence_hash: string;
        height: number;
        last_block_id: {
            hash: string;
            parts: {
                hash: string;
                total: number;
            };
        };
        last_commit_hash: string;
        last_results_hash: string;
        next_validators_hash: string;
        proposer_address: string;
        time: string;
        validators_hash: string;
        version: {
            app: string;
            block: string;
        };
    };
    id: {
        hash: string;
        parts: {
            hash: string;
            total: number;
        };
    };
    txs: Array<BlockTx> | null;
};

export type BlockTx = {
    hash: string;
    result: {
        code?: number;
        codespace?: string;
        data?: string;
        events?: Array<{
            [key: string]: (string);
        }> | null;
        gas_used?: string;
        gas_wanted?: string;
        info?: string;
        log?: string;
    };
    tx: {
        [key: string]: unknown;
    };
};

export type Borrower = {
    asset: string;
    collateral_current: string;
    collateral_deposited: string;
    collateral_withdrawn: string;
    debt_current: string;
    debt_issued: string;
    debt_repaid: string;
    last_open_height: number;
    last_repay_height: number;
    owner: string;
};

export type BorrowerResponse = Borrower;

export type BorrowersResponse = Array<Borrower>;

export type Coin = {
    amount: string;
    asset: string;
    decimals?: number;
};

export type ConstantsResponse = {
    bool_values?: {
        [key: string]: (string);
    };
    int_64_values?: {
        [key: string]: (string);
    };
    string_values?: {
        [key: string]: (string);
    };
};

export type DerivedPool = {
    asset: string;
    balance_asset: string;
    balance_rune: string;
    decimals?: number;
    /**
     * the depth of the derived virtual pool relative to L1 pool (in basis points)
     */
    derived_depth_bps: string;
    status: string;
};

export type DerivedPoolResponse = DerivedPool;

export type DerivedPoolsResponse = Array<DerivedPool>;

export type InboundAddress = {
    address?: string;
    chain?: string;
    /**
     * Returns true if LP actions are paused for this chain
     */
    chain_lp_actions_paused?: boolean;
    /**
     * Returns true if trading is paused for this chain
     */
    chain_trading_paused?: boolean;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * The minimum fee rate used by vaults to send outbound TXs. The actual fee rate may be higher. For EVM chains this is returned in gwei (1e9).
     */
    gas_rate?: string;
    /**
     * Units of the gas_rate.
     */
    gas_rate_units?: string;
    /**
     * Returns true if trading is paused globally
     */
    global_trading_paused?: boolean;
    /**
     * Returns true if trading is unavailable for this chain, either because trading is halted globally or specifically for this chain
     */
    halted: boolean;
    /**
     * The total outbound fee charged to the user for outbound txs in the gas asset of the chain.
     */
    outbound_fee?: string;
    /**
     * Avg size of outbound TXs on each chain. For UTXO chains it may be larger than average, as it takes into account vault consolidation txs, which can have many vouts
     */
    outbound_tx_size?: string;
    pub_key?: string;
    router?: string;
};

export type InboundAddressesResponse = Array<InboundAddress>;

export type InvariantResponse = {
    /**
     * Returns true if the invariant is broken.
     */
    broken: boolean;
    /**
     * The name of the invariant.
     */
    invariant: string;
    /**
     * Informative message about the invariant result.
     */
    msg: Array<(string)>;
};

export type InvariantsResponse = {
    invariants?: Array<(string)>;
};

export type KeygenMetric = {
    node_tss_times: Array<{
        address?: string;
        tss_time?: string;
    }>;
    pub_key?: string;
};

export type KeygenMetricsResponse = Array<KeygenMetric>;

export type KeygenResponse = {
    keygen_block: {
        /**
         * the height of the keygen block
         */
        height?: number;
        keygens: Array<{
            id?: string;
            members?: Array<(string)>;
            type?: string;
        }>;
    };
    signature: string;
};

export type KeysignResponse = {
    keysign: {
        /**
         * the block(s) in which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue
         */
        height?: number;
        tx_array: Array<TxOutItem>;
    };
    signature: string;
};

export type LastBlock = {
    chain: string;
    last_observed_in: number;
    last_signed_out: number;
    thorchain: number;
};

export type LastBlockResponse = Array<LastBlock>;

export type LiquidityProvider = {
    asset: string;
    asset_address?: string;
    asset_deposit_value: string;
    asset_redeem_value?: string;
    last_add_height?: number;
    last_withdraw_height?: number;
    luvi_deposit_value?: string;
    luvi_growth_pct?: string;
    luvi_redeem_value?: string;
    pending_asset: string;
    pending_rune: string;
    pending_tx_id?: string;
    rune_address?: string;
    rune_deposit_value: string;
    rune_redeem_value?: string;
    units: string;
};

export type LiquidityProviderResponse = LiquidityProvider;

export type LiquidityProviderSummary = {
    asset: string;
    asset_address?: string;
    asset_deposit_value: string;
    last_add_height?: number;
    last_withdraw_height?: number;
    pending_asset: string;
    pending_rune: string;
    pending_tx_id?: string;
    rune_address?: string;
    rune_deposit_value: string;
    units: string;
};

export type LiquidityProvidersResponse = Array<LiquidityProviderSummary>;

export type MetricsResponse = {
    keygen?: KeygenMetricsResponse;
    keysign?: {
        node_tss_times?: Array<TssMetric>;
        tx_id?: string;
    };
};

export type MimirNodesResponse = {
    mimirs?: Array<{
        key?: string;
        signer?: string;
        value?: number;
    }>;
};

export type MimirResponse = {
    [key: string]: (string);
};

export type MsgSwap = {
    /**
     * the affiliate address which will receive any affiliate fee
     */
    affiliate_address?: string;
    /**
     * the affiliate fee in basis points
     */
    affiliate_basis_points: string;
    /**
     * the contract address if an aggregator is specified for a non-THORChain SwapOut
     */
    aggregator?: string;
    /**
     * the desired output asset of the aggregator SwapOut
     */
    aggregator_target_address?: string;
    /**
     * the minimum amount of SwapOut asset to receive (else cancelling the SwapOut and receiving THORChain's output)
     */
    aggregator_target_limit?: string;
    /**
     * the destination address to receive the swap output
     */
    destination?: string;
    /**
     * market if immediately completed or refunded, limit if held until fulfillable
     */
    order_type?: string;
    /**
     * the signer (sender) of the transaction
     */
    signer?: string;
    /**
     * the interval (in blocks) to execute the streaming swap
     */
    stream_interval?: number;
    /**
     * number of swaps to execute in a streaming swap
     */
    stream_quantity?: number;
    /**
     * the asset to be swapped to
     */
    target_asset: string;
    /**
     * the minimum amount of output asset to receive (else cancelling and refunding the swap)
     */
    trade_target: string;
    tx: Tx;
};

export type NetworkResponse = {
    /**
     * total amount of RUNE awarded to node operators
     */
    bond_reward_rune: string;
    /**
     * effective security bond used to determine maximum pooled RUNE
     */
    effective_security_bond: string;
    /**
     * Sum of the gas the network has spent to send outbounds
     */
    gas_spent_rune: string;
    /**
     * Sum of the gas withheld from users to cover outbound gas
     */
    gas_withheld_rune: string;
    /**
     * the outbound transaction fee in rune, converted from the NativeOutboundFeeUSD mimir (after USD fees are enabled)
     */
    native_outbound_fee_rune: string;
    /**
     * the native transaction fee in rune, converted from the NativeTransactionFeeUSD mimir (after USD fees are enabled)
     */
    native_tx_fee_rune: string;
    /**
     * Current outbound fee multiplier, in basis points
     */
    outbound_fee_multiplier?: string;
    /**
     * the rune price in tor
     */
    rune_price_in_tor: string;
    /**
     * the thorname fee per block in rune, converted from the TNSFeePerBlockUSD mimir (after USD fees are enabled)
     */
    tns_fee_per_block_rune: string;
    /**
     * the thorname register fee in rune, converted from the TNSRegisterFeeUSD mimir (after USD fees are enabled)
     */
    tns_register_fee_rune: string;
    /**
     * the tor price in rune
     */
    tor_price_in_rune: string;
    /**
     * total bonded RUNE
     */
    total_bond_units: string;
    /**
     * total reserve RUNE
     */
    total_reserve: string;
    /**
     * Returns true if there exist RetiringVaults which have not finished migrating funds to new ActiveVaults
     */
    vaults_migrating: boolean;
};

export type Node = {
    /**
     * the block height at which the node became active
     */
    active_block_height: number;
    bond_providers: {
        /**
         * node operator fee in basis points
         */
        node_operator_fee: string;
        /**
         * all the bond providers for the node
         */
        providers: Array<{
            bond?: string;
            bond_address?: string;
        }>;
    };
    current_award: string;
    /**
     * indicates whether the node has been forced to leave by the network, typically via ban
     */
    forced_to_leave: boolean;
    ip_address: string;
    jail: {
        reason?: string;
        release_height?: number;
    };
    leave_height: number;
    node_address: string;
    node_operator_address: string;
    /**
     * the last observed heights for all chain by the node
     */
    observe_chains: Array<{
        chain: string;
        height: number;
    }>;
    /**
     * the P2PID (:6040/p2pid endpoint) of the node
     */
    peer_id: string;
    preflight_status: {
        code: number;
        /**
         * the reason for the transition to the next status
         */
        reason: string;
        /**
         * the next status of the node
         */
        status: string;
    };
    pub_key_set: {
        ed25519?: string;
        secp256k1?: string;
    };
    requested_to_leave: boolean;
    /**
     * the set of vault public keys of which the node is a member
     */
    signer_membership: Array<(string)>;
    /**
     * the accumulated slash points, reset at churn but excessive slash points may carry over
     */
    slash_points: number;
    status: 'Active' | 'Whitelisted' | 'Standby' | 'Disabled';
    /**
     * the block height of the current provided information for the node
     */
    status_since: number;
    /**
     * current node bond
     */
    total_bond: string;
    /**
     * the consensus pub key for the node
     */
    validator_cons_pub_key: string;
    /**
     * the currently set version of the node
     */
    version: string;
};

export type status = 'Active' | 'Whitelisted' | 'Standby' | 'Disabled';

export type NodeResponse = Node;

export type NodesResponse = Array<Node>;

export type ObservedTx = {
    /**
     * the outbound aggregator to use, will also match a suffix
     */
    aggregator?: string;
    /**
     * the aggregator target asset provided to transferOutAndCall
     */
    aggregator_target?: string;
    /**
     * the aggregator target asset limit provided to transferOutAndCall
     */
    aggregator_target_limit?: string;
    /**
     * the block height on the external source chain when confirmation counting will be complete, not provided if chain is THOR
     */
    external_confirmation_delay_height?: number;
    /**
     * the block height on the external source chain when the transaction was observed, not provided if chain is THOR
     */
    external_observed_height?: number;
    keysign_ms?: number;
    observed_pub_key?: string;
    out_hashes?: Array<(string)>;
    signers?: Array<(string)>;
    status?: 'done' | 'incomplete';
    tx: Tx;
};

export type status2 = 'done' | 'incomplete';

export type OutboundFee = {
    /**
     * the asset to display the outbound fee for
     */
    asset: string;
    /**
     * dynamic multiplier basis points, based on the surplus_rune, affecting the size of the outbound_fee
     */
    dynamic_multiplier_basis_points?: string;
    /**
     * Total RUNE the network has spent to reimburse gas costs for this asset's outbounds
     */
    fee_spent_rune?: string;
    /**
     * Total RUNE the network has withheld as fees to later cover gas costs for this asset's outbounds
     */
    fee_withheld_rune?: string;
    /**
     * the asset's outbound fee, in (1e8-format) units of the asset
     */
    outbound_fee: string;
    /**
     * amount of RUNE by which the fee_withheld_rune exceeds the fee_spent_rune
     */
    surplus_rune?: string;
};

export type OutboundFeesResponse = Array<OutboundFee>;

export type OutboundResponse = Array<TxOutItem>;

export type POL = {
    /**
     * current amount of rune deposited
     */
    current_deposit: string;
    /**
     * profit and loss of protocol owned liquidity
     */
    pnl: string;
    /**
     * total amount of RUNE deposited into the pools
     */
    rune_deposited: string;
    /**
     * total amount of RUNE withdrawn from the pools
     */
    rune_withdrawn: string;
    /**
     * total value of protocol's LP position in RUNE value
     */
    value: string;
};

export type Pool = {
    /**
     * the total pool liquidity provider units
     */
    LP_units: string;
    asset: string;
    /**
     * the USD (TOR) price of the asset in 1e8
     */
    asset_tor_price: string;
    balance_asset: string;
    balance_rune: string;
    decimals?: number;
    /**
     * the depth of the derived virtual pool relative to L1 pool (in basis points)
     */
    derived_depth_bps: string;
    /**
     * the amount of collateral collects for loans
     */
    loan_collateral: string;
    /**
     * the amount of remaining collateral collects for loans
     */
    loan_collateral_remaining: string;
    /**
     * the current loan collateralization ratio
     */
    loan_cr: string;
    pending_inbound_asset: string;
    pending_inbound_rune: string;
    /**
     * the total pool units, this is the sum of LP and synth units
     */
    pool_units: string;
    /**
     * amount of remaining capacity in asset
     */
    savers_capacity_remaining: string;
    /**
     * the balance of L1 asset deposited into the Savers Vault
     */
    savers_depth: string;
    /**
     * the filled savers capacity in basis points, 4500/10000 = 45%
     */
    savers_fill_bps: string;
    /**
     * the number of units owned by Savers
     */
    savers_units: string;
    short_code?: string;
    status: string;
    /**
     * whether additional synths cannot be minted
     */
    synth_mint_paused: boolean;
    /**
     * the total supply of synths for the asset
     */
    synth_supply: string;
    /**
     * the amount of synth supply remaining before the current max supply is reached
     */
    synth_supply_remaining: string;
    /**
     * the total synth units in the pool
     */
    synth_units: string;
};

export type PoolResponse = Pool;

export type PoolSlipResponse = Array<{
    asset: string;
    /**
     * Median of rollup snapshots over a long period
     */
    long_rollup: number;
    /**
     * Pool slip for this asset's pool for the current height
     */
    pool_slip: number;
    /**
     * Stored sum of pool slips over a number of previous block heights
     */
    rollup: number;
    /**
     * Number of stored pool slips contributing to the current stored rollup
     */
    rollup_count: number;
    /**
     * Summed pool slips over a number of previous block heights, to checksum the stored rollup
     */
    summed_rollup?: number;
}>;

export type PoolsResponse = Array<Pool>;

export type QueueResponse = {
    internal: number;
    /**
     * number of signed outbound tx in the queue
     */
    outbound: number;
    /**
     * scheduled outbound clout in RUNE
     */
    scheduled_outbound_clout: string;
    /**
     * scheduled outbound value in RUNE
     */
    scheduled_outbound_value: string;
    swap: number;
};

export type QuoteFees = {
    /**
     * affiliate fee in the target asset
     */
    affiliate?: string;
    /**
     * the target asset used for all fees
     */
    asset: string;
    /**
     * liquidity fees paid to pools in the target asset
     */
    liquidity: string;
    /**
     * outbound fee in the target asset
     */
    outbound?: string;
    /**
     * the swap slippage in basis points
     */
    slippage_bps: number;
    /**
     * total fees in the target asset
     */
    total: string;
    /**
     * total basis points in fees relative to amount out
     */
    total_bps: number;
};

export type QuoteLoanCloseResponse = {
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * The quantity of the repayment asset to be sent by the user, calculated as the desired percentage of the loan's value, expressed in units of 1e8
     */
    expected_amount_in: string;
    /**
     * the amount of collateral asset the user can expect to receive after fees in 1e8 decimals
     */
    expected_amount_out: string;
    /**
     * the expected amount of collateral decrease on the loan
     */
    expected_collateral_withdrawn: string;
    /**
     * the expected amount of TOR debt decrease on the loan
     */
    expected_debt_repaid: string;
    /**
     * expiration timestamp in unix seconds
     */
    expiry: number;
    fees: QuoteFees;
    /**
     * the units of the recommended gas rate
     */
    gas_rate_units?: string;
    /**
     * the inbound address for the transaction on the source chain
     */
    inbound_address?: string;
    /**
     * the approximate number of source chain blocks required before processing
     */
    inbound_confirmation_blocks?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     */
    inbound_confirmation_seconds?: number;
    /**
     * generated memo for the loan close
     */
    memo: string;
    /**
     * chain specific quote notes
     */
    notes: string;
    /**
     * the number of thorchain blocks the outbound will be delayed
     */
    outbound_delay_blocks: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     */
    outbound_delay_seconds: number;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     */
    recommended_gas_rate?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     */
    recommended_min_amount_in?: string;
    /**
     * the EVM chain router contract address
     */
    router?: string;
    /**
     * The number of blocks involved in the streaming swaps during the repayment process.
     */
    streaming_swap_blocks: number;
    /**
     * The approximate number of seconds taken by the streaming swaps involved in the repayment process.
     */
    streaming_swap_seconds: number;
    /**
     * The total expected duration for a repayment, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
     */
    total_repay_seconds: number;
    /**
     * static warning message
     */
    warning: string;
};

export type QuoteLoanOpenResponse = {
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * the amount of the target asset the user can expect to receive after fees in 1e8 decimals
     */
    expected_amount_out: string;
    /**
     * the expected amount of collateral increase on the loan
     */
    expected_collateral_deposited: string;
    /**
     * the expected collateralization ratio in basis points
     */
    expected_collateralization_ratio: string;
    /**
     * the expected amount of TOR debt increase on the loan
     */
    expected_debt_issued: string;
    /**
     * expiration timestamp in unix seconds
     */
    expiry: number;
    fees: QuoteFees;
    /**
     * the units of the recommended gas rate
     */
    gas_rate_units: string;
    /**
     * the inbound address for the transaction on the source chain
     */
    inbound_address?: string;
    /**
     * the approximate number of source chain blocks required before processing
     */
    inbound_confirmation_blocks?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     */
    inbound_confirmation_seconds?: number;
    /**
     * generated memo for the loan open
     */
    memo?: string;
    /**
     * chain specific quote notes
     */
    notes: string;
    /**
     * the number of thorchain blocks the outbound will be delayed
     */
    outbound_delay_blocks: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     */
    outbound_delay_seconds: number;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     */
    recommended_gas_rate: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     */
    recommended_min_amount_in?: string;
    /**
     * the EVM chain router contract address
     */
    router?: string;
    /**
     * The number of blocks involved in the streaming swaps during the open loan process.
     */
    streaming_swap_blocks: number;
    /**
     * The approximate number of seconds taken by the streaming swaps involved in the open loan process.
     */
    streaming_swap_seconds: number;
    /**
     * The total expected duration for a open loan, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
     */
    total_open_loan_seconds: number;
    /**
     * static warning message
     */
    warning: string;
};

export type QuoteSaverDepositResponse = {
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * the amount of the target asset the user can expect to deposit after fees
     */
    expected_amount_deposit: string;
    /**
     * same as expected_amount_deposit, to be deprecated in favour of expected_amount_deposit
     */
    expected_amount_out?: string;
    /**
     * expiration timestamp in unix seconds
     */
    expiry: number;
    fees: QuoteFees;
    /**
     * the units of the recommended gas rate
     */
    gas_rate_units: string;
    /**
     * the inbound address for the transaction on the source chain
     */
    inbound_address: string;
    /**
     * the approximate number of source chain blocks required before processing
     */
    inbound_confirmation_blocks?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     */
    inbound_confirmation_seconds?: number;
    /**
     * generated memo for the deposit
     */
    memo: string;
    /**
     * chain specific quote notes
     */
    notes: string;
    /**
     * the number of thorchain blocks the outbound will be delayed
     */
    outbound_delay_blocks?: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     */
    outbound_delay_seconds?: number;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     */
    recommended_gas_rate: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     */
    recommended_min_amount_in?: string;
    /**
     * the EVM chain router contract address
     */
    router?: string;
    /**
     * static warning message
     */
    warning: string;
};

export type QuoteSaverWithdrawResponse = {
    /**
     * the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo
     */
    dust_amount: string;
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * the amount of the target asset the user can expect to withdraw after fees in 1e8 decimals
     */
    expected_amount_out: string;
    /**
     * expiration timestamp in unix seconds
     */
    expiry: number;
    fees: QuoteFees;
    /**
     * the units of the recommended gas rate
     */
    gas_rate_units: string;
    /**
     * the inbound address for the transaction on the source chain
     */
    inbound_address: string;
    /**
     * the approximate number of source chain blocks required before processing
     */
    inbound_confirmation_blocks?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     */
    inbound_confirmation_seconds?: number;
    /**
     * generated memo for the withdraw, the client can use this OR send the dust amount
     */
    memo: string;
    /**
     * chain specific quote notes
     */
    notes: string;
    /**
     * the number of thorchain blocks the outbound will be delayed
     */
    outbound_delay_blocks: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     */
    outbound_delay_seconds: number;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     */
    recommended_gas_rate: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     */
    recommended_min_amount_in?: string;
    /**
     * the EVM chain router contract address
     */
    router?: string;
    /**
     * static warning message
     */
    warning: string;
};

export type QuoteSwapResponse = {
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * the amount of the target asset the user can expect to receive after fees
     */
    expected_amount_out: string;
    /**
     * expiration timestamp in unix seconds
     */
    expiry: number;
    fees: QuoteFees;
    /**
     * the units of the recommended gas rate
     */
    gas_rate_units?: string;
    /**
     * the inbound address for the transaction on the source chain
     */
    inbound_address?: string;
    /**
     * the approximate number of source chain blocks required before processing
     */
    inbound_confirmation_blocks?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     */
    inbound_confirmation_seconds?: number;
    /**
     * the maximum amount of trades a streaming swap can do for a trade
     */
    max_streaming_quantity?: number;
    /**
     * generated memo for the swap
     */
    memo?: string;
    /**
     * chain specific quote notes
     */
    notes: string;
    /**
     * the number of thorchain blocks the outbound will be delayed
     */
    outbound_delay_blocks: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     */
    outbound_delay_seconds: number;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     */
    recommended_gas_rate?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     */
    recommended_min_amount_in?: string;
    /**
     * the EVM chain router contract address
     */
    router?: string;
    /**
     * the number of blocks the streaming swap will execute over
     */
    streaming_swap_blocks?: number;
    /**
     * approx the number of seconds the streaming swap will execute over
     */
    streaming_swap_seconds?: number;
    /**
     * total number of seconds a swap is expected to take (inbound conf + streaming swap + outbound delay)
     */
    total_swap_seconds?: number;
    /**
     * static warning message
     */
    warning: string;
};

export type RUNEPoolResponse = {
    pol: POL;
    providers: {
        /**
         * the current RUNE deposited by providers
         */
        current_deposit: string;
        /**
         * the amount of RUNE pending
         */
        pending_rune: string;
        /**
         * the units of RUNEPool owned by providers that remain pending
         */
        pending_units: string;
        /**
         * the profit and loss of the provider share of the RUNEPool
         */
        pnl: string;
        /**
         * the units of RUNEPool owned by providers (including pending)
         */
        units: string;
        /**
         * the value of the provider share of the RUNEPool (includes pending RUNE)
         */
        value: string;
    };
    reserve: {
        /**
         * the current RUNE deposited by the reserve
         */
        current_deposit: string;
        /**
         * the profit and loss of the reserve share of the RUNEPool
         */
        pnl: string;
        /**
         * the units of RUNEPool owned by the reserve
         */
        units: string;
        /**
         * the value of the reserve share of the RUNEPool
         */
        value: string;
    };
};

export type RUNEProvider = {
    deposit_amount: string;
    last_deposit_height: number;
    last_withdraw_height: number;
    pnl: string;
    rune_address: string;
    units: string;
    value: string;
    withdraw_amount: string;
};

export type RUNEProviderResponse = RUNEProvider;

export type RUNEProvidersResponse = Array<RUNEProvider>;

export type Saver = {
    asset: string;
    asset_address: string;
    asset_deposit_value: string;
    asset_redeem_value: string;
    growth_pct: string;
    last_add_height?: number;
    last_withdraw_height?: number;
    units: string;
};

export type SaverResponse = Saver;

export type SaversResponse = Array<Saver>;

export type ScheduledResponse = Array<TxOutItem>;

export type StreamingSwap = {
    /**
     * the amount of swap attempts so far
     */
    count?: number;
    /**
     * the number of input tokens the swapper has deposited
     */
    deposit: string;
    /**
     * the destination address to receive the swap output
     */
    destination?: string;
    /**
     * the list of reasons that sub-swaps have failed
     */
    failed_swap_reasons?: Array<(string)>;
    /**
     * the list of swap indexes that failed
     */
    failed_swaps?: Array<(number)>;
    /**
     * the amount of input tokens that have been swapped so far
     */
    in: string;
    /**
     * how often each swap is made, in blocks
     */
    interval?: number;
    /**
     * the block height of the latest swap
     */
    last_height?: number;
    /**
     * the amount of output tokens that have been swapped so far
     */
    out: string;
    /**
     * the total number of swaps in a streaming swaps
     */
    quantity?: number;
    /**
     * the asset to be swapped from
     */
    source_asset?: string;
    /**
     * the asset to be swapped to
     */
    target_asset?: string;
    /**
     * the total number of tokens the swapper wants to receive of the output asset
     */
    trade_target: string;
    /**
     * the hash of a transaction
     */
    tx_id?: string;
};

export type StreamingSwapResponse = StreamingSwap;

export type StreamingSwapsResponse = Array<StreamingSwap>;

export type SwapQueueResponse = Array<MsgSwap>;

export type SwapperCloutResponse = {
    /**
     * address associated with this clout account
     */
    address: string;
    /**
     * last block height that clout was reclaimed
     */
    last_reclaim_height?: number;
    /**
     * last block height that clout was spent
     */
    last_spent_height?: number;
    /**
     * amount of clout that has been reclaimed in total over time (observed clout spent)
     */
    reclaimed?: string;
    /**
     * clout score, which is the amount of rune spent on swap fees
     */
    score?: string;
    /**
     * amount of clout that has been spent in total over time
     */
    spent?: string;
};

export type Thorname = {
    /**
     * Amount of RUNE currently accrued by this thorname in affiliate fees waiting to be swapped to preferred asset.
     */
    affiliate_collector_rune?: string;
    aliases: Array<ThornameAlias>;
    expire_block_height?: number;
    name?: string;
    owner?: string;
    preferred_asset: string;
};

export type ThornameAlias = {
    address?: string;
    chain?: string;
};

export type ThornameResponse = Thorname;

export type TradeAccountResponse = {
    /**
     * trade account asset with "~" separator
     */
    asset: string;
    /**
     * last thorchain height trade assets were added to trade account
     */
    last_add_height?: number;
    /**
     * last thorchain height trade assets were withdrawn from trade account
     */
    last_withdraw_height?: number;
    /**
     * thor address of trade account owner
     */
    owner: string;
    /**
     * units of trade asset belonging to this owner
     */
    units: string;
};

export type TradeAccountsResponse = Array<TradeAccountResponse>;

export type TradeUnitResponse = {
    /**
     * trade account asset with "~" separator
     */
    asset: string;
    /**
     * total depth of trade asset
     */
    depth: string;
    /**
     * total units of trade asset
     */
    units: string;
};

export type TradeUnitsResponse = Array<TradeUnitResponse>;

export type TssKeysignMetric = {
    node_tss_times: Array<TssMetric>;
    tx_id?: string;
};

export type TssMetric = {
    address?: string;
    tss_time?: number;
};

export type Tx = {
    chain?: string;
    coins: Array<Coin>;
    from_address?: string;
    gas: Array<Coin>;
    id?: string;
    memo?: string;
    to_address?: string;
};

export type TxDetailsResponse = {
    actions: Array<TxOutItem>;
    /**
     * the thorchain height at which the inbound reached consensus
     */
    consensus_height?: number;
    /**
     * the thorchain height at which the outbound was finalised
     */
    finalised_height?: number;
    out_txs: Array<Tx>;
    /**
     * the thorchain height for which the outbound was scheduled
     */
    outbound_height?: number;
    reverted?: boolean;
    tx: ObservedTx;
    tx_id?: string;
    txs: Array<ObservedTx>;
    updated_vault?: boolean;
};

export type TxOutItem = {
    chain: string;
    /**
     * clout spent in RUNE for the outbound
     */
    clout_spent?: string;
    coin: Coin;
    gas_rate?: number;
    height?: number;
    in_hash?: string;
    max_gas: Array<Coin>;
    memo?: string;
    out_hash?: string;
    to_address: string;
    vault_pub_key?: string;
};

export type TxResponse = {
    /**
     * the thorchain height at which the inbound reached consensus
     */
    consensus_height?: number;
    /**
     * the thorchain height at which the outbound was finalised
     */
    finalised_height?: number;
    keysign_metric?: TssKeysignMetric;
    observed_tx?: ObservedTx;
    /**
     * the thorchain height for which the outbound was scheduled
     */
    outbound_height?: number;
};

export type TxSignersResponse = {
    actions: Array<TxOutItem>;
    /**
     * the thorchain height at which the inbound reached consensus
     */
    consensus_height?: number;
    /**
     * the thorchain height at which the outbound was finalised
     */
    finalised_height?: number;
    out_txs: Array<Tx>;
    /**
     * the thorchain height for which the outbound was scheduled
     */
    outbound_height?: number;
    reverted?: boolean;
    tx: ObservedTx;
    tx_id?: string;
    txs: Array<ObservedTx>;
    updated_vault?: boolean;
};

export type TxStagesResponse = {
    inbound_confirmation_counted?: {
        /**
         * the external source chain for which confirmation counting takes place
         */
        chain?: string;
        /**
         * returns true if no transaction confirmation counting remains to be done
         */
        completed: boolean;
        /**
         * the THORChain block height when confirmation counting began
         */
        counting_start_height?: number;
        /**
         * the block height on the external source chain when confirmation counting will be complete
         */
        external_confirmation_delay_height?: number;
        /**
         * the block height on the external source chain when the transaction was observed
         */
        external_observed_height?: number;
        /**
         * the estimated remaining seconds before confirmation counting completes
         */
        remaining_confirmation_seconds?: number;
    };
    inbound_finalised?: {
        /**
         * returns true if the inbound transaction has been finalised (THORChain agreeing it exists)
         */
        completed: boolean;
    };
    inbound_observed: {
        /**
         * returns true if no transaction observation remains to be done
         */
        completed: boolean;
        /**
         * number of signers for final observations, after any confirmation counting complete
         */
        final_count: number;
        /**
         * number of signers for pre-confirmation-counting observations
         */
        pre_confirmation_count?: number;
        /**
         * returns true if any nodes have observed the transaction (to be deprecated in favour of counts)
         */
        started?: boolean;
    };
    outbound_delay?: {
        /**
         * returns true if no transaction outbound delay remains
         */
        completed: boolean;
        /**
         * the number of remaining THORChain blocks the outbound will be delayed
         */
        remaining_delay_blocks?: number;
        /**
         * the estimated remaining seconds of the outbound delay before it will be sent
         */
        remaining_delay_seconds?: number;
    };
    outbound_signed?: {
        /**
         * THORChain blocks since the scheduled outbound height
         */
        blocks_since_scheduled?: number;
        /**
         * returns true if an external transaction has been signed and broadcast (and observed in its mempool)
         */
        completed: boolean;
        /**
         * THORChain height for which the external outbound is scheduled
         */
        scheduled_outbound_height?: number;
    };
    swap_finalised?: {
        /**
         * (to be deprecated in favor of swap_status) returns true if an inbound transaction's swap (successful or refunded) is no longer pending
         */
        completed: boolean;
    };
    swap_status?: {
        /**
         * true when awaiting a swap
         */
        pending: boolean;
        streaming?: {
            /**
             * the amount of swap attempts so far
             */
            count: number;
            /**
             * how often each swap is made, in blocks
             */
            interval: number;
            /**
             * the total number of swaps in a streaming swaps
             */
            quantity: number;
        };
    };
};

export type TxStatusResponse = {
    out_txs?: Array<Tx>;
    planned_out_txs?: Array<{
        chain: string;
        coin: Coin;
        /**
         * returns true if the planned transaction has a refund memo
         */
        refund: boolean;
        to_address: string;
    }>;
    stages: TxStagesResponse;
    tx?: Tx;
};

export type UpgradeProposal = {
    /**
     * whether the upgrade has been approved by the active validators
     */
    approved?: boolean;
    /**
     * the percentage of active validators that have approved the upgrade
     */
    approved_percent?: string;
    /**
     * the block height at which the upgrade will occur
     */
    height: number;
    /**
     * the description of the upgrade, typically json with URLs to binaries for use with automation tools
     */
    info: string;
    /**
     * the name of the upgrade
     */
    name: string;
    /**
     * the amount of additional active validators required to reach quorum for the upgrade
     */
    validators_to_quorum?: number;
};

export type UpgradeProposalResponse = UpgradeProposal;

export type UpgradeProposalsResponse = Array<UpgradeProposal>;

export type UpgradeVote = {
    /**
     * the node address of the voter
     */
    node_address: string;
    /**
     * the vote cast by the node
     */
    vote: 'approve' | 'reject';
};

/**
 * the vote cast by the node
 */
export type vote = 'approve' | 'reject';

export type UpgradeVotesResponse = Array<UpgradeVote>;

export type Vault = {
    addresses: Array<VaultAddress>;
    block_height?: number;
    chains?: Array<(string)>;
    coins: Array<Coin>;
    frozen?: Array<(string)>;
    inbound_tx_count?: number;
    /**
     * the list of node public keys which are members of the vault
     */
    membership?: Array<(string)>;
    outbound_tx_count?: number;
    pending_tx_block_heights?: Array<(number)>;
    pub_key?: string;
    routers: Array<VaultRouter>;
    status: string;
    status_since?: number;
    type?: 'AsgardVault' | 'YggdrasilVault';
};

export type type = 'AsgardVault' | 'YggdrasilVault';

export type VaultAddress = {
    address: string;
    chain: string;
};

export type VaultInfo = {
    pub_key: string;
    routers: Array<VaultRouter>;
};

export type VaultPubkeysResponse = {
    asgard: Array<VaultInfo>;
    inactive: Array<VaultInfo>;
    yggdrasil: Array<VaultInfo>;
};

export type VaultResponse = Vault;

export type VaultRouter = {
    chain?: string;
    router?: string;
};

export type VaultsResponse = Array<Vault>;

export type VersionResponse = {
    /**
     * current version
     */
    current: string;
    /**
     * next version (minimum version for a node to become Active)
     */
    next: string;
    /**
     * height at which the minimum joining version last changed
     */
    next_since_height?: number;
    /**
     * querier version
     */
    querier: string;
};

export type YggdrasilVault = {
    addresses: Array<VaultAddress>;
    block_height?: number;
    /**
     * current node bond
     */
    bond: string;
    chains?: Array<(string)>;
    coins: Array<Coin>;
    inbound_tx_count?: number;
    /**
     * the list of node public keys which are members of the vault
     */
    membership?: Array<(string)>;
    outbound_tx_count?: number;
    pending_tx_block_heights?: Array<(number)>;
    pub_key?: string;
    routers: Array<VaultRouter>;
    status: string;
    status_since?: number;
    /**
     * value in rune of the vault's assets
     */
    total_value: string;
    type?: 'AsgardVault' | 'YggdrasilVault';
};

export type YggdrasilVaultsResponse = Array<YggdrasilVault>;

export type baseQuoteResponse = {
    /**
     * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
     */
    dust_threshold?: string;
    /**
     * expiration timestamp in unix seconds
     */
    expiry?: number;
    fees?: QuoteFees;
    /**
     * the units of the recommended gas rate
     */
    gas_rate_units?: string;
    /**
     * the inbound address for the transaction on the source chain
     */
    inbound_address?: string;
    /**
     * the approximate number of source chain blocks required before processing
     */
    inbound_confirmation_blocks?: number;
    /**
     * the approximate seconds for block confirmations required before processing
     */
    inbound_confirmation_seconds?: number;
    /**
     * chain specific quote notes
     */
    notes?: string;
    /**
     * the number of thorchain blocks the outbound will be delayed
     */
    outbound_delay_blocks?: number;
    /**
     * the approximate seconds for the outbound delay before it will be sent
     */
    outbound_delay_seconds?: number;
    /**
     * the recommended gas rate to use for the inbound to ensure timely confirmation
     */
    recommended_gas_rate?: string;
    /**
     * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
     */
    recommended_min_amount_in?: string;
    /**
     * the EVM chain router contract address
     */
    router?: string;
    /**
     * static warning message
     */
    warning?: string;
};

export type Parameteraddress = string;

export type Parameterasset = string;

export type Parameterchain = string;

export type Parameterhash = string;

export type Parameterinvariant = string;

export type Parametername = string;

export type ParameterpathHeight = number;

export type Parameterpubkey = string;

/**
 * optional block height, defaults to current tip
 */
export type ParameterqueryHeight = number;

export type BanData = {
    path: {
        address: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type BanResponse2 = (BanResponse);

export type BanError = unknown;

export type BlockData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type BlockResponse2 = (BlockResponse);

export type BlockError = unknown;

export type SwapperCloutData = {
    path: {
        address: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type SwapperCloutResponse2 = (SwapperCloutResponse);

export type SwapperCloutError = unknown;

export type ConstantsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type ConstantsResponse2 = (ConstantsResponse);

export type ConstantsError = unknown;

export type DpoolData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type DpoolResponse = (DerivedPool);

export type DpoolError = unknown;

export type DpoolsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type DpoolsResponse = (DerivedPoolsResponse);

export type DpoolsError = unknown;

export type InboundAddressesData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type InboundAddressesResponse2 = (InboundAddressesResponse);

export type InboundAddressesError = unknown;

export type InvariantData = {
    path: {
        invariant: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type InvariantResponse2 = (InvariantResponse);

export type InvariantError = unknown;

export type InvariantsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type InvariantsResponse2 = (InvariantsResponse);

export type InvariantsError = unknown;

export type KeygenPubkeyData = {
    path: {
        height: number;
        pubkey: string;
    };
};

export type KeygenPubkeyResponse = (KeygenResponse);

export type KeygenPubkeyError = unknown;

export type KeysignData = {
    path: {
        height: number;
    };
};

export type KeysignResponse2 = (KeysignResponse);

export type KeysignError = unknown;

export type KeysignPubkeyData = {
    path: {
        height: number;
        pubkey: string;
    };
};

export type KeysignPubkeyResponse = (KeysignResponse);

export type KeysignPubkeyError = unknown;

export type LastblockData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type LastblockResponse = (LastBlockResponse);

export type LastblockError = unknown;

export type LastblockChainData = {
    path: {
        chain: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type LastblockChainResponse = (LastBlockResponse);

export type LastblockChainError = unknown;

export type MetricsKeygenData = {
    path: {
        pubkey: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MetricsKeygenResponse = (KeygenMetricsResponse);

export type MetricsKeygenError = unknown;

export type MetricsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MetricsResponse2 = (MetricsResponse);

export type MetricsError = unknown;

export type MimirData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MimirResponse2 = (MimirResponse);

export type MimirError = unknown;

export type MimirAdminData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MimirAdminResponse = (MimirResponse);

export type MimirAdminError = unknown;

export type MimirKeyData = {
    path: {
        /**
         * the mimir key to lookup
         */
        key: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MimirKeyResponse = (number);

export type MimirKeyError = unknown;

export type MimirNodeData = {
    path: {
        address: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MimirNodeResponse = (MimirResponse);

export type MimirNodeError = unknown;

export type MimirNodesData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type MimirNodesResponse2 = (MimirNodesResponse);

export type MimirNodesError = unknown;

export type NetworkData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type NetworkResponse2 = (NetworkResponse);

export type NetworkError = unknown;

export type NodeData = {
    path: {
        address: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type NodeResponse2 = (Node);

export type NodeError = unknown;

export type NodesData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type NodesResponse2 = (NodesResponse);

export type NodesError = unknown;

export type OutboundFeeAssetData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type OutboundFeeAssetResponse = (OutboundFeesResponse);

export type OutboundFeeAssetError = unknown;

export type OutboundFeesData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type OutboundFeesResponse2 = (OutboundFeesResponse);

export type OutboundFeesError = unknown;

export type PingResponse = ({
    ping?: string;
});

export type PingError = unknown;

export type PoolData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type PoolResponse2 = (Pool);

export type PoolError = unknown;

export type BorrowerData = {
    path: {
        address: string;
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type BorrowerResponse2 = (Borrower);

export type BorrowerError = unknown;

export type BorrowersData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type BorrowersResponse2 = (BorrowersResponse);

export type BorrowersError = unknown;

export type LiquidityProviderData = {
    path: {
        address: string;
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type LiquidityProviderResponse2 = (LiquidityProvider);

export type LiquidityProviderError = unknown;

export type LiquidityProvidersData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type LiquidityProvidersResponse2 = (LiquidityProvidersResponse);

export type LiquidityProvidersError = unknown;

export type SaverData = {
    path: {
        address: string;
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type SaverResponse2 = (Saver);

export type SaverError = unknown;

export type SaversData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type SaversResponse2 = (SaversResponse);

export type SaversError = unknown;

export type PoolsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type PoolsResponse2 = (PoolsResponse);

export type PoolsError = unknown;

export type QueueData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type QueueResponse2 = (QueueResponse);

export type QueueError = unknown;

export type QueueOutboundData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type QueueOutboundResponse = (OutboundResponse);

export type QueueOutboundError = unknown;

export type QueueScheduledData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type QueueScheduledResponse = (ScheduledResponse);

export type QueueScheduledError = unknown;

export type QueueSwapData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type QueueSwapResponse = (SwapQueueResponse);

export type QueueSwapError = unknown;

export type QuoteloancloseData = {
    query?: {
        /**
         * the asset used to repay the loan
         */
        from_asset?: string;
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
        /**
         * the owner of the loan collateral
         */
        loan_owner?: string;
        /**
         * the minimum amount of the target asset to accept
         */
        min_out?: string;
        /**
         * the basis points of the existing position to repay
         */
        repay_bps?: number;
        /**
         * the collateral asset of the loan
         */
        to_asset?: string;
    };
};

export type QuoteloancloseResponse = (QuoteLoanCloseResponse);

export type QuoteloancloseError = unknown;

export type QuoteloanopenData = {
    query?: {
        /**
         * the affiliate (address or thorname)
         */
        affiliate?: string;
        /**
         * the affiliate fee in basis points
         */
        affiliate_bps?: number;
        /**
         * the collateral asset amount in 1e8 decimals
         */
        amount?: number;
        /**
         * the destination address, required to generate memo
         */
        destination?: string;
        /**
         * the collateral asset
         */
        from_asset?: string;
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
        /**
         * the minimum amount of the target asset to accept
         */
        min_out?: string;
        /**
         * the target asset to receive (loan denominated in TOR regardless)
         */
        to_asset?: string;
    };
};

export type QuoteloanopenResponse = (QuoteLoanOpenResponse);

export type QuoteloanopenError = unknown;

export type QuotesaverdepositData = {
    query?: {
        /**
         * the source asset amount in 1e8 decimals
         */
        amount?: number;
        /**
         * the asset to deposit
         */
        asset?: string;
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type QuotesaverdepositResponse = (QuoteSaverDepositResponse);

export type QuotesaverdepositError = unknown;

export type QuotesaverwithdrawData = {
    query?: {
        /**
         * the address for the position
         */
        address?: string;
        /**
         * the asset to withdraw
         */
        asset?: string;
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
        /**
         * the basis points of the existing position to withdraw
         */
        withdraw_bps?: number;
    };
};

export type QuotesaverwithdrawResponse = (QuoteSaverWithdrawResponse);

export type QuotesaverwithdrawError = unknown;

export type QuoteswapData = {
    query?: {
        /**
         * the affiliate (address or thorname)
         */
        affiliate?: string;
        /**
         * the affiliate fee in basis points
         */
        affiliate_bps?: number;
        /**
         * the source asset amount in 1e8 decimals
         */
        amount?: number;
        /**
         * the destination address, required to generate memo
         */
        destination?: string;
        /**
         * the source asset
         */
        from_asset?: string;
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
        /**
         * the refund address, refunds will be sent here if the swap fails
         */
        refund_address?: string;
        /**
         * the interval in which streaming swaps are swapped
         */
        streaming_interval?: number;
        /**
         * the quantity of swaps within a streaming swap
         */
        streaming_quantity?: number;
        /**
         * the target asset
         */
        to_asset?: string;
        /**
         * the maximum basis points from the current feeless swap price to set the limit in the generated memo
         */
        tolerance_bps?: number;
    };
};

export type QuoteswapResponse = (QuoteSwapResponse);

export type QuoteswapError = unknown;

export type RagnarokData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type RagnarokResponse = (boolean);

export type RagnarokError = unknown;

export type RuneProviderData = {
    path: {
        address: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type RuneProviderResponse = (RUNEProvider);

export type RuneProviderError = unknown;

export type RuneProvidersData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type RuneProvidersResponse = (RUNEProvidersResponse);

export type RuneProvidersError = unknown;

export type RunePoolData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type RunePoolResponse = (RUNEPoolResponse);

export type RunePoolError = unknown;

export type PoolslipData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type PoolslipResponse = (PoolSlipResponse);

export type PoolslipError = unknown;

export type PoolslipsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type PoolslipsResponse = (PoolSlipResponse);

export type PoolslipsError = unknown;

export type StreamSwapData = {
    path: {
        hash: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type StreamSwapResponse = (StreamingSwap);

export type StreamSwapError = unknown;

export type StreamSwapsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type StreamSwapsResponse = (StreamingSwapsResponse);

export type StreamSwapsError = unknown;

export type ThornameData = {
    path: {
        /**
         * the thornode to lookup
         */
        name: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type ThornameResponse2 = (Thorname);

export type ThornameError = unknown;

export type TradeAccountData = {
    path: {
        address: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TradeAccountResponse2 = (TradeAccountResponse);

export type TradeAccountError = unknown;

export type TradeAccountsData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TradeAccountsResponse2 = (TradeAccountsResponse);

export type TradeAccountsError = unknown;

export type TradeUnitData = {
    path: {
        asset: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TradeUnitResponse2 = (TradeUnitResponse);

export type TradeUnitError = unknown;

export type TradeUnitsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TradeUnitsResponse2 = (TradeUnitsResponse);

export type TradeUnitsError = unknown;

export type TxSignersData = {
    path: {
        hash: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TxSignersResponse2 = (TxDetailsResponse);

export type TxSignersError = unknown;

export type TxStagesData = {
    path: {
        hash: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TxStagesResponse2 = (TxStagesResponse);

export type TxStagesError = unknown;

export type TxStatusData = {
    path: {
        hash: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TxStatusResponse2 = (TxStatusResponse);

export type TxStatusError = unknown;

export type TxData = {
    path: {
        hash: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TxResponse2 = (TxResponse);

export type TxError = unknown;

export type TxSignersOldData = {
    path: {
        hash: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type TxSignersOldResponse = (TxSignersResponse);

export type TxSignersOldError = unknown;

export type UpgradeProposalData = {
    path: {
        name: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type UpgradeProposalResponse2 = (UpgradeProposal);

export type UpgradeProposalError = unknown;

export type UpgradeProposalsData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type UpgradeProposalsResponse2 = (UpgradeProposalsResponse);

export type UpgradeProposalsError = unknown;

export type UpgradeVotesData = {
    path: {
        name: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type UpgradeVotesResponse2 = (UpgradeVotesResponse);

export type UpgradeVotesError = unknown;

export type VaultData = {
    path: {
        pubkey: string;
    };
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type VaultResponse2 = (Vault);

export type VaultError = unknown;

export type AsgardData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type AsgardResponse = (VaultsResponse);

export type AsgardError = unknown;

export type VaultPubkeysData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type VaultPubkeysResponse2 = (VaultPubkeysResponse);

export type VaultPubkeysError = unknown;

export type YggdrasilData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type YggdrasilResponse = (YggdrasilVaultsResponse);

export type YggdrasilError = unknown;

export type VersionData = {
    query?: {
        /**
         * optional block height, defaults to current tip
         */
        height?: number;
    };
};

export type VersionResponse2 = (VersionResponse);

export type VersionError = unknown;