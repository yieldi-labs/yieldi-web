// This file is auto-generated by @hey-api/openapi-ts

export type QuoteSaverWithdrawResponse = {
  /**
   * static warning message
   */
  warning: string;
  /**
   * the recommended gas rate to use for the inbound to ensure timely confirmation
   */
  recommended_gas_rate: string;
  fees: QuoteFees;
  /**
   * the approximate seconds for block confirmations required before processing
   */
  inbound_confirmation_seconds?: number;
  /**
   * the EVM chain router contract address
   */
  router?: string;
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  /**
   * the amount of the target asset the user can expect to withdraw after fees in 1e8 decimals
   */
  expected_amount_out: string;
  /**
   * the approximate number of source chain blocks required before processing
   */
  inbound_confirmation_blocks?: number;
  /**
   * expiration timestamp in unix seconds
   */
  expiry: number;
  /**
   * chain specific quote notes
   */
  notes: string;
  /**
   * the units of the recommended gas rate
   */
  gas_rate_units: string;
  /**
   * the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo
   */
  dust_amount: string;
  /**
   * the inbound address for the transaction on the source chain
   */
  inbound_address: string;
  /**
   * the approximate seconds for the outbound delay before it will be sent
   */
  outbound_delay_seconds: number;
  /**
   * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
   */
  recommended_min_amount_in?: string;
  /**
   * generated memo for the withdraw, the client can use this OR send the dust amount
   */
  memo: string;
  /**
   * the number of thorchain blocks the outbound will be delayed
   */
  outbound_delay_blocks: number;
};

export type YggdrasilVault = {
  pending_tx_block_heights?: Array<number>;
  inbound_tx_count?: number;
  /**
   * the list of node public keys which are members of the vault
   */
  membership?: Array<string>;
  chains?: Array<string>;
  routers: Array<VaultRouter>;
  status: string;
  pub_key?: string;
  status_since?: number;
  /**
   * current node bond
   */
  bond: string;
  block_height?: number;
  type?: "AsgardVault" | "YggdrasilVault";
  outbound_tx_count?: number;
  /**
   * value in rune of the vault's assets
   */
  total_value: string;
  addresses: Array<VaultAddress>;
  coins: Array<Coin>;
};

export type type = "AsgardVault" | "YggdrasilVault";

export type StreamingSwapsResponse = Array<StreamingSwap>;

export type SwapQueueResponse = Array<MsgSwap>;

export type TradeAccountResponse = {
  /**
   * trade account asset with "~" separator
   */
  asset: string;
  /**
   * units of trade asset belonging to this owner
   */
  units: string;
  /**
   * thor address of trade account owner
   */
  owner: string;
  /**
   * last thorchain height trade assets were added to trade account
   */
  last_add_height?: number;
  /**
   * last thorchain height trade assets were withdrawn from trade account
   */
  last_withdraw_height?: number;
};

export type ScheduledResponse = Array<TxOutItem>;

export type MimirResponse = {
  [key: string]: string;
};

export type Coin = {
  asset: string;
  amount: string;
  decimals?: number;
};

export type BlockTx = {
  hash: string;
  tx: {
    [key: string]: unknown;
  };
  result: {
    events?: Array<{
      [key: string]: string;
    }> | null;
    codespace?: string;
    code?: number;
    data?: string;
    log?: string;
    info?: string;
    gas_wanted?: string;
    gas_used?: string;
  };
};

export type PoolSlipResponse = Array<{
  asset: string;
  /**
   * Pool slip for this asset's pool for the current height
   */
  pool_slip: number;
  /**
   * Number of stored pool slips contributing to the current stored rollup
   */
  rollup_count: number;
  /**
   * Median of rollup snapshots over a long period
   */
  long_rollup: number;
  /**
   * Stored sum of pool slips over a number of previous block heights
   */
  rollup: number;
  /**
   * Summed pool slips over a number of previous block heights, to checksum the stored rollup
   */
  summed_rollup?: number;
}>;

export type BorrowerResponse = Borrower;

export type LiquidityProviderResponse = LiquidityProvider;

export type ConstantsResponse = {
  int_64_values?: {
    [key: string]: string;
  };
  bool_values?: {
    [key: string]: string;
  };
  string_values?: {
    [key: string]: string;
  };
};

export type baseQuoteResponse = {
  /**
   * the number of thorchain blocks the outbound will be delayed
   */
  outbound_delay_blocks?: number;
  /**
   * static warning message
   */
  warning?: string;
  /**
   * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
   */
  recommended_min_amount_in?: string;
  /**
   * the inbound address for the transaction on the source chain
   */
  inbound_address?: string;
  /**
   * the approximate seconds for block confirmations required before processing
   */
  inbound_confirmation_seconds?: number;
  /**
   * expiration timestamp in unix seconds
   */
  expiry?: number;
  /**
   * the recommended gas rate to use for the inbound to ensure timely confirmation
   */
  recommended_gas_rate?: string;
  /**
   * the units of the recommended gas rate
   */
  gas_rate_units?: string;
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  /**
   * the approximate number of source chain blocks required before processing
   */
  inbound_confirmation_blocks?: number;
  /**
   * the approximate seconds for the outbound delay before it will be sent
   */
  outbound_delay_seconds?: number;
  fees?: QuoteFees;
  /**
   * the EVM chain router contract address
   */
  router?: string;
  /**
   * chain specific quote notes
   */
  notes?: string;
};

export type Vault = {
  coins: Array<Coin>;
  status: string;
  outbound_tx_count?: number;
  addresses: Array<VaultAddress>;
  block_height?: number;
  status_since?: number;
  inbound_tx_count?: number;
  routers: Array<VaultRouter>;
  pub_key?: string;
  chains?: Array<string>;
  pending_tx_block_heights?: Array<number>;
  frozen?: Array<string>;
  /**
   * the list of node public keys which are members of the vault
   */
  membership?: Array<string>;
  type?: "AsgardVault" | "YggdrasilVault";
};

export type VaultInfo = {
  pub_key: string;
  routers: Array<VaultRouter>;
};

export type TxOutItem = {
  out_hash?: string;
  height?: number;
  memo?: string;
  in_hash?: string;
  vault_pub_key?: string;
  coin: Coin;
  max_gas: Array<Coin>;
  gas_rate?: number;
  /**
   * clout spent in RUNE for the outbound
   */
  clout_spent?: string;
  chain: string;
  to_address: string;
};

export type KeygenMetric = {
  pub_key?: string;
  node_tss_times: Array<{
    address?: string;
    tss_time?: string;
  }>;
};

export type Borrower = {
  debt_current: string;
  collateral_deposited: string;
  asset: string;
  debt_repaid: string;
  collateral_withdrawn: string;
  collateral_current: string;
  last_open_height: number;
  last_repay_height: number;
  owner: string;
  debt_issued: string;
};

export type MsgSwap = {
  /**
   * the minimum amount of SwapOut asset to receive (else cancelling the SwapOut and receiving THORChain's output)
   */
  aggregator_target_limit?: string;
  /**
   * market if immediately completed or refunded, limit if held until fulfillable
   */
  order_type?: string;
  /**
   * the destination address to receive the swap output
   */
  destination?: string;
  /**
   * the minimum amount of output asset to receive (else cancelling and refunding the swap)
   */
  trade_target: string;
  /**
   * the affiliate fee in basis points
   */
  affiliate_basis_points: string;
  /**
   * the contract address if an aggregator is specified for a non-THORChain SwapOut
   */
  aggregator?: string;
  /**
   * the desired output asset of the aggregator SwapOut
   */
  aggregator_target_address?: string;
  /**
   * number of swaps to execute in a streaming swap
   */
  stream_quantity?: number;
  /**
   * the interval (in blocks) to execute the streaming swap
   */
  stream_interval?: number;
  tx: Tx;
  /**
   * the asset to be swapped to
   */
  target_asset: string;
  /**
   * the affiliate address which will receive any affiliate fee
   */
  affiliate_address?: string;
  /**
   * the signer (sender) of the transaction
   */
  signer?: string;
};

export type TssMetric = {
  address?: string;
  tss_time?: number;
};

export type QuoteLoanOpenResponse = {
  /**
   * the approximate seconds for the outbound delay before it will be sent
   */
  outbound_delay_seconds: number;
  fees: QuoteFees;
  /**
   * expiration timestamp in unix seconds
   */
  expiry: number;
  /**
   * static warning message
   */
  warning: string;
  /**
   * chain specific quote notes
   */
  notes: string;
  /**
   * the approximate number of source chain blocks required before processing
   */
  inbound_confirmation_blocks?: number;
  /**
   * the approximate seconds for block confirmations required before processing
   */
  inbound_confirmation_seconds?: number;
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  /**
   * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
   */
  recommended_min_amount_in?: string;
  /**
   * the recommended gas rate to use for the inbound to ensure timely confirmation
   */
  recommended_gas_rate: string;
  /**
   * the units of the recommended gas rate
   */
  gas_rate_units: string;
  /**
   * the expected amount of collateral increase on the loan
   */
  expected_collateral_deposited: string;
  /**
   * The approximate number of seconds taken by the streaming swaps involved in the open loan process.
   */
  streaming_swap_seconds: number;
  /**
   * the inbound address for the transaction on the source chain
   */
  inbound_address?: string;
  /**
   * the number of thorchain blocks the outbound will be delayed
   */
  outbound_delay_blocks: number;
  /**
   * The number of blocks involved in the streaming swaps during the open loan process.
   */
  streaming_swap_blocks: number;
  /**
   * the EVM chain router contract address
   */
  router?: string;
  /**
   * the expected amount of TOR debt increase on the loan
   */
  expected_debt_issued: string;
  /**
   * the expected collateralization ratio in basis points
   */
  expected_collateralization_ratio: string;
  /**
   * The total expected duration for a open loan, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
   */
  total_open_loan_seconds: number;
  /**
   * generated memo for the loan open
   */
  memo?: string;
  /**
   * the amount of the target asset the user can expect to receive after fees in 1e8 decimals
   */
  expected_amount_out: string;
};

export type Thorname = {
  name?: string;
  expire_block_height?: number;
  owner?: string;
  preferred_asset: string;
  /**
   * Amount of RUNE currently accrued by this thorname in affiliate fees waiting to be swapped to preferred asset.
   */
  affiliate_collector_rune?: string;
  aliases: Array<ThornameAlias>;
};

export type PoolsResponse = Array<Pool>;

export type VersionResponse = {
  /**
   * height at which the minimum joining version last changed
   */
  next_since_height?: number;
  /**
   * querier version
   */
  querier: string;
  /**
   * current version
   */
  current: string;
  /**
   * next version (minimum version for a node to become Active)
   */
  next: string;
};

export type UpgradeVotesResponse = Array<UpgradeVote>;

export type KeygenResponse = {
  keygen_block: {
    /**
     * the height of the keygen block
     */
    height?: number;
    keygens: Array<{
      type?: string;
      members?: Array<string>;
      id?: string;
    }>;
  };
  signature: string;
};

export type ThornameResponse = Thorname;

export type Pool = {
  status: string;
  balance_asset: string;
  /**
   * the total pool liquidity provider units
   */
  LP_units: string;
  /**
   * amount of remaining capacity in asset
   */
  savers_capacity_remaining: string;
  /**
   * whether additional synths cannot be minted
   */
  synth_mint_paused: boolean;
  /**
   * the amount of remaining collateral collects for loans
   */
  loan_collateral_remaining: string;
  pending_inbound_asset: string;
  /**
   * the total pool units, this is the sum of LP and synth units
   */
  pool_units: string;
  /**
   * the amount of synth supply remaining before the current max supply is reached
   */
  synth_supply_remaining: string;
  /**
   * the amount of collateral collects for loans
   */
  loan_collateral: string;
  asset: string;
  short_code?: string;
  balance_rune: string;
  /**
   * the USD (TOR) price of the asset in 1e8
   */
  asset_tor_price: string;
  /**
   * the balance of L1 asset deposited into the Savers Vault
   */
  savers_depth: string;
  /**
   * the number of units owned by Savers
   */
  savers_units: string;
  /**
   * the current loan collateralization ratio
   */
  loan_cr: string;
  decimals?: number;
  pending_inbound_rune: string;
  /**
   * the total synth units in the pool
   */
  synth_units: string;
  /**
   * the total supply of synths for the asset
   */
  synth_supply: string;
  /**
   * the filled savers capacity in basis points, 4500/10000 = 45%
   */
  savers_fill_bps: string;
  /**
   * the depth of the derived virtual pool relative to L1 pool (in basis points)
   */
  derived_depth_bps: string;
};

export type VaultAddress = {
  chain: string;
  address: string;
};

export type RUNEPoolResponse = {
  providers: {
    /**
     * the current RUNE deposited by providers
     */
    current_deposit: string;
    /**
     * the units of RUNEPool owned by providers (including pending)
     */
    units: string;
    /**
     * the units of RUNEPool owned by providers that remain pending
     */
    pending_units: string;
    /**
     * the amount of RUNE pending
     */
    pending_rune: string;
    /**
     * the value of the provider share of the RUNEPool (includes pending RUNE)
     */
    value: string;
    /**
     * the profit and loss of the provider share of the RUNEPool
     */
    pnl: string;
  };
  reserve: {
    /**
     * the units of RUNEPool owned by the reserve
     */
    units: string;
    /**
     * the value of the reserve share of the RUNEPool
     */
    value: string;
    /**
     * the profit and loss of the reserve share of the RUNEPool
     */
    pnl: string;
    /**
     * the current RUNE deposited by the reserve
     */
    current_deposit: string;
  };
  pol: POL;
};

export type NodesResponse = Array<Node>;

export type SaversResponse = Array<Saver>;

export type BorrowersResponse = Array<Borrower>;

export type DerivedPool = {
  decimals?: number;
  balance_asset: string;
  balance_rune: string;
  /**
   * the depth of the derived virtual pool relative to L1 pool (in basis points)
   */
  derived_depth_bps: string;
  asset: string;
  status: string;
};

export type RUNEProvidersResponse = Array<RUNEProvider>;

export type TxResponse = {
  observed_tx?: ObservedTx;
  /**
   * the thorchain height at which the inbound reached consensus
   */
  consensus_height?: number;
  /**
   * the thorchain height at which the outbound was finalised
   */
  finalised_height?: number;
  /**
   * the thorchain height for which the outbound was scheduled
   */
  outbound_height?: number;
  keysign_metric?: TssKeysignMetric;
};

export type LastBlockResponse = Array<LastBlock>;

export type ObservedTx = {
  /**
   * the aggregator target asset limit provided to transferOutAndCall
   */
  aggregator_target_limit?: string;
  signers?: Array<string>;
  keysign_ms?: number;
  out_hashes?: Array<string>;
  status?: "done" | "incomplete";
  tx: Tx;
  /**
   * the outbound aggregator to use, will also match a suffix
   */
  aggregator?: string;
  /**
   * the aggregator target asset provided to transferOutAndCall
   */
  aggregator_target?: string;
  observed_pub_key?: string;
  /**
   * the block height on the external source chain when the transaction was observed, not provided if chain is THOR
   */
  external_observed_height?: number;
  /**
   * the block height on the external source chain when confirmation counting will be complete, not provided if chain is THOR
   */
  external_confirmation_delay_height?: number;
};

export type status = "done" | "incomplete";

export type UpgradeVote = {
  /**
   * the node address of the voter
   */
  node_address: string;
  /**
   * the vote cast by the node
   */
  vote: "approve" | "reject";
};

/**
 * the vote cast by the node
 */
export type vote = "approve" | "reject";

export type RUNEProviderResponse = RUNEProvider;

export type Tx = {
  coins: Array<Coin>;
  gas: Array<Coin>;
  memo?: string;
  id?: string;
  chain?: string;
  from_address?: string;
  to_address?: string;
};

export type TssKeysignMetric = {
  tx_id?: string;
  node_tss_times: Array<TssMetric>;
};

export type DerivedPoolResponse = DerivedPool;

export type TxDetailsResponse = {
  actions: Array<TxOutItem>;
  out_txs: Array<Tx>;
  /**
   * the thorchain height at which the inbound reached consensus
   */
  consensus_height?: number;
  updated_vault?: boolean;
  /**
   * the thorchain height for which the outbound was scheduled
   */
  outbound_height?: number;
  tx_id?: string;
  tx: ObservedTx;
  txs: Array<ObservedTx>;
  /**
   * the thorchain height at which the outbound was finalised
   */
  finalised_height?: number;
  reverted?: boolean;
};

export type POL = {
  /**
   * total amount of RUNE deposited into the pools
   */
  rune_deposited: string;
  /**
   * total amount of RUNE withdrawn from the pools
   */
  rune_withdrawn: string;
  /**
   * total value of protocol's LP position in RUNE value
   */
  value: string;
  /**
   * profit and loss of protocol owned liquidity
   */
  pnl: string;
  /**
   * current amount of rune deposited
   */
  current_deposit: string;
};

export type LiquidityProviderSummary = {
  last_withdraw_height?: number;
  units: string;
  pending_rune: string;
  asset_deposit_value: string;
  asset: string;
  rune_address?: string;
  pending_asset: string;
  pending_tx_id?: string;
  rune_deposit_value: string;
  asset_address?: string;
  last_add_height?: number;
};

export type Saver = {
  last_add_height?: number;
  last_withdraw_height?: number;
  units: string;
  asset_deposit_value: string;
  asset_redeem_value: string;
  growth_pct: string;
  asset: string;
  asset_address: string;
};

export type StreamingSwap = {
  /**
   * the asset to be swapped from
   */
  source_asset?: string;
  /**
   * the list of swap indexes that failed
   */
  failed_swaps?: Array<number>;
  /**
   * the total number of swaps in a streaming swaps
   */
  quantity?: number;
  /**
   * the block height of the latest swap
   */
  last_height?: number;
  /**
   * the total number of tokens the swapper wants to receive of the output asset
   */
  trade_target: string;
  /**
   * the list of reasons that sub-swaps have failed
   */
  failed_swap_reasons?: Array<string>;
  /**
   * how often each swap is made, in blocks
   */
  interval?: number;
  /**
   * the destination address to receive the swap output
   */
  destination?: string;
  /**
   * the asset to be swapped to
   */
  target_asset?: string;
  /**
   * the number of input tokens the swapper has deposited
   */
  deposit: string;
  /**
   * the amount of input tokens that have been swapped so far
   */
  in: string;
  /**
   * the amount of output tokens that have been swapped so far
   */
  out: string;
  /**
   * the hash of a transaction
   */
  tx_id?: string;
  /**
   * the amount of swap attempts so far
   */
  count?: number;
};

export type TxStatusResponse = {
  tx?: Tx;
  planned_out_txs?: Array<{
    chain: string;
    to_address: string;
    coin: Coin;
    /**
     * returns true if the planned transaction has a refund memo
     */
    refund: boolean;
  }>;
  out_txs?: Array<Tx>;
  stages: TxStagesResponse;
};

export type VaultResponse = Vault;

export type StreamingSwapResponse = StreamingSwap;

export type UpgradeProposalsResponse = Array<UpgradeProposal>;

export type QueueResponse = {
  swap: number;
  /**
   * number of signed outbound tx in the queue
   */
  outbound: number;
  internal: number;
  /**
   * scheduled outbound value in RUNE
   */
  scheduled_outbound_value: string;
  /**
   * scheduled outbound clout in RUNE
   */
  scheduled_outbound_clout: string;
};

export type MetricsResponse = {
  keygen?: KeygenMetricsResponse;
  keysign?: {
    tx_id?: string;
    node_tss_times?: Array<TssMetric>;
  };
};

export type VaultRouter = {
  router?: string;
  chain?: string;
};

export type OutboundFee = {
  /**
   * the asset to display the outbound fee for
   */
  asset: string;
  /**
   * the asset's outbound fee, in (1e8-format) units of the asset
   */
  outbound_fee: string;
  /**
   * Total RUNE the network has withheld as fees to later cover gas costs for this asset's outbounds
   */
  fee_withheld_rune?: string;
  /**
   * Total RUNE the network has spent to reimburse gas costs for this asset's outbounds
   */
  fee_spent_rune?: string;
  /**
   * amount of RUNE by which the fee_withheld_rune exceeds the fee_spent_rune
   */
  surplus_rune?: string;
  /**
   * dynamic multiplier basis points, based on the surplus_rune, affecting the size of the outbound_fee
   */
  dynamic_multiplier_basis_points?: string;
};

export type QuoteFees = {
  /**
   * the swap slippage in basis points
   */
  slippage_bps: number;
  /**
   * total basis points in fees relative to amount out
   */
  total_bps: number;
  /**
   * the target asset used for all fees
   */
  asset: string;
  /**
   * affiliate fee in the target asset
   */
  affiliate?: string;
  /**
   * outbound fee in the target asset
   */
  outbound?: string;
  /**
   * liquidity fees paid to pools in the target asset
   */
  liquidity: string;
  /**
   * total fees in the target asset
   */
  total: string;
};

export type NodeResponse = Node;

export type InvariantResponse = {
  /**
   * The name of the invariant.
   */
  invariant: string;
  /**
   * Returns true if the invariant is broken.
   */
  broken: boolean;
  /**
   * Informative message about the invariant result.
   */
  msg: Array<string>;
};

export type BanResponse = {
  node_address?: string;
  block_height?: number;
  signers?: Array<string>;
};

export type OutboundResponse = Array<TxOutItem>;

export type BlockResponse = {
  header: {
    chain_id: string;
    last_commit_hash: string;
    last_results_hash: string;
    version: {
      block: string;
      app: string;
    };
    height: number;
    time: string;
    validators_hash: string;
    next_validators_hash: string;
    data_hash: string;
    consensus_hash: string;
    app_hash: string;
    last_block_id: {
      hash: string;
      parts: {
        total: number;
        hash: string;
      };
    };
    evidence_hash: string;
    proposer_address: string;
  };
  begin_block_events: Array<{
    [key: string]: string;
  }>;
  end_block_events: Array<{
    [key: string]: string;
  }>;
  txs: Array<BlockTx> | null;
  id: {
    hash: string;
    parts: {
      total: number;
      hash: string;
    };
  };
};

export type LiquidityProvider = {
  rune_redeem_value?: string;
  asset_redeem_value?: string;
  luvi_deposit_value?: string;
  asset: string;
  rune_address?: string;
  last_add_height?: number;
  pending_rune: string;
  asset_address?: string;
  units: string;
  asset_deposit_value: string;
  luvi_redeem_value?: string;
  luvi_growth_pct?: string;
  last_withdraw_height?: number;
  pending_asset: string;
  pending_tx_id?: string;
  rune_deposit_value: string;
};

export type PoolResponse = Pool;

export type InboundAddressesResponse = Array<InboundAddress>;

export type UpgradeProposalResponse = UpgradeProposal;

export type SaverResponse = Saver;

export type VaultPubkeysResponse = {
  asgard: Array<VaultInfo>;
  yggdrasil: Array<VaultInfo>;
  inactive: Array<VaultInfo>;
};

export type OutboundFeesResponse = Array<OutboundFee>;

export type MimirNodesResponse = {
  mimirs?: Array<{
    signer?: string;
    key?: string;
    value?: number;
  }>;
};

export type RUNEProvider = {
  rune_address: string;
  units: string;
  value: string;
  pnl: string;
  deposit_amount: string;
  withdraw_amount: string;
  last_deposit_height: number;
  last_withdraw_height: number;
};

export type InboundAddress = {
  /**
   * The minimum fee rate used by vaults to send outbound TXs. The actual fee rate may be higher. For EVM chains this is returned in gwei (1e9).
   */
  gas_rate?: string;
  /**
   * The total outbound fee charged to the user for outbound txs in the gas asset of the chain.
   */
  outbound_fee?: string;
  address?: string;
  router?: string;
  /**
   * Returns true if trading is unavailable for this chain, either because trading is halted globally or specifically for this chain
   */
  halted: boolean;
  /**
   * Returns true if trading is paused globally
   */
  global_trading_paused?: boolean;
  /**
   * Returns true if trading is paused for this chain
   */
  chain_trading_paused?: boolean;
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  chain?: string;
  pub_key?: string;
  /**
   * Returns true if LP actions are paused for this chain
   */
  chain_lp_actions_paused?: boolean;
  /**
   * Units of the gas_rate.
   */
  gas_rate_units?: string;
  /**
   * Avg size of outbound TXs on each chain. For UTXO chains it may be larger than average, as it takes into account vault consolidation txs, which can have many vouts
   */
  outbound_tx_size?: string;
};

export type UpgradeProposal = {
  /**
   * the percentage of active validators that have approved the upgrade
   */
  approved_percent?: string;
  /**
   * the amount of additional active validators required to reach quorum for the upgrade
   */
  validators_to_quorum?: number;
  /**
   * the name of the upgrade
   */
  name: string;
  /**
   * the block height at which the upgrade will occur
   */
  height: number;
  /**
   * the description of the upgrade, typically json with URLs to binaries for use with automation tools
   */
  info: string;
  /**
   * whether the upgrade has been approved by the active validators
   */
  approved?: boolean;
};

export type LiquidityProvidersResponse = Array<LiquidityProviderSummary>;

export type QuoteSwapResponse = {
  /**
   * the amount of the target asset the user can expect to receive after fees
   */
  expected_amount_out: string;
  /**
   * the approximate number of source chain blocks required before processing
   */
  inbound_confirmation_blocks?: number;
  fees: QuoteFees;
  /**
   * expiration timestamp in unix seconds
   */
  expiry: number;
  /**
   * chain specific quote notes
   */
  notes: string;
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  /**
   * the units of the recommended gas rate
   */
  gas_rate_units?: string;
  /**
   * the maximum amount of trades a streaming swap can do for a trade
   */
  max_streaming_quantity?: number;
  /**
   * total number of seconds a swap is expected to take (inbound conf + streaming swap + outbound delay)
   */
  total_swap_seconds?: number;
  /**
   * the inbound address for the transaction on the source chain
   */
  inbound_address?: string;
  /**
   * the approximate seconds for block confirmations required before processing
   */
  inbound_confirmation_seconds?: number;
  /**
   * the number of thorchain blocks the outbound will be delayed
   */
  outbound_delay_blocks: number;
  /**
   * generated memo for the swap
   */
  memo?: string;
  /**
   * approx the number of seconds the streaming swap will execute over
   */
  streaming_swap_seconds?: number;
  /**
   * the number of blocks the streaming swap will execute over
   */
  streaming_swap_blocks?: number;
  /**
   * the approximate seconds for the outbound delay before it will be sent
   */
  outbound_delay_seconds: number;
  /**
   * the EVM chain router contract address
   */
  router?: string;
  /**
   * static warning message
   */
  warning: string;
  /**
   * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
   */
  recommended_min_amount_in?: string;
  /**
   * the recommended gas rate to use for the inbound to ensure timely confirmation
   */
  recommended_gas_rate?: string;
};

export type InvariantsResponse = {
  invariants?: Array<string>;
};

export type LastBlock = {
  chain: string;
  last_observed_in: number;
  last_signed_out: number;
  thorchain: number;
};

export type Node = {
  node_address: string;
  /**
   * the P2PID (:6040/p2pid endpoint) of the node
   */
  peer_id: string;
  /**
   * current node bond
   */
  total_bond: string;
  current_award: string;
  node_operator_address: string;
  /**
   * the currently set version of the node
   */
  version: string;
  /**
   * the last observed heights for all chain by the node
   */
  observe_chains: Array<{
    chain: string;
    height: number;
  }>;
  /**
   * the block height at which the node became active
   */
  active_block_height: number;
  /**
   * the set of vault public keys of which the node is a member
   */
  signer_membership: Array<string>;
  requested_to_leave: boolean;
  /**
   * indicates whether the node has been forced to leave by the network, typically via ban
   */
  forced_to_leave: boolean;
  leave_height: number;
  ip_address: string;
  jail: {
    release_height?: number;
    reason?: string;
  };
  status: "Active" | "Whitelisted" | "Standby" | "Disabled";
  pub_key_set: {
    secp256k1?: string;
    ed25519?: string;
  };
  /**
   * the consensus pub key for the node
   */
  validator_cons_pub_key: string;
  /**
   * the block height of the current provided information for the node
   */
  status_since: number;
  bond_providers: {
    /**
     * node operator fee in basis points
     */
    node_operator_fee: string;
    /**
     * all the bond providers for the node
     */
    providers: Array<{
      bond_address?: string;
      bond?: string;
    }>;
  };
  /**
   * the accumulated slash points, reset at churn but excessive slash points may carry over
   */
  slash_points: number;
  preflight_status: {
    /**
     * the next status of the node
     */
    status: string;
    /**
     * the reason for the transition to the next status
     */
    reason: string;
    code: number;
  };
};

export type status2 = "Active" | "Whitelisted" | "Standby" | "Disabled";

export type TxStagesResponse = {
  inbound_finalised?: {
    /**
     * returns true if the inbound transaction has been finalised (THORChain agreeing it exists)
     */
    completed: boolean;
  };
  swap_status?: {
    /**
     * true when awaiting a swap
     */
    pending: boolean;
    streaming?: {
      /**
       * how often each swap is made, in blocks
       */
      interval: number;
      /**
       * the total number of swaps in a streaming swaps
       */
      quantity: number;
      /**
       * the amount of swap attempts so far
       */
      count: number;
    };
  };
  swap_finalised?: {
    /**
     * (to be deprecated in favor of swap_status) returns true if an inbound transaction's swap (successful or refunded) is no longer pending
     */
    completed: boolean;
  };
  outbound_delay?: {
    /**
     * the number of remaining THORChain blocks the outbound will be delayed
     */
    remaining_delay_blocks?: number;
    /**
     * the estimated remaining seconds of the outbound delay before it will be sent
     */
    remaining_delay_seconds?: number;
    /**
     * returns true if no transaction outbound delay remains
     */
    completed: boolean;
  };
  outbound_signed?: {
    /**
     * THORChain height for which the external outbound is scheduled
     */
    scheduled_outbound_height?: number;
    /**
     * THORChain blocks since the scheduled outbound height
     */
    blocks_since_scheduled?: number;
    /**
     * returns true if an external transaction has been signed and broadcast (and observed in its mempool)
     */
    completed: boolean;
  };
  inbound_observed: {
    /**
     * number of signers for final observations, after any confirmation counting complete
     */
    final_count: number;
    /**
     * returns true if no transaction observation remains to be done
     */
    completed: boolean;
    /**
     * returns true if any nodes have observed the transaction (to be deprecated in favour of counts)
     */
    started?: boolean;
    /**
     * number of signers for pre-confirmation-counting observations
     */
    pre_confirmation_count?: number;
  };
  inbound_confirmation_counted?: {
    /**
     * the external source chain for which confirmation counting takes place
     */
    chain?: string;
    /**
     * the block height on the external source chain when the transaction was observed
     */
    external_observed_height?: number;
    /**
     * the block height on the external source chain when confirmation counting will be complete
     */
    external_confirmation_delay_height?: number;
    /**
     * the estimated remaining seconds before confirmation counting completes
     */
    remaining_confirmation_seconds?: number;
    /**
     * returns true if no transaction confirmation counting remains to be done
     */
    completed: boolean;
    /**
     * the THORChain block height when confirmation counting began
     */
    counting_start_height?: number;
  };
};

export type YggdrasilVaultsResponse = Array<YggdrasilVault>;

export type TradeUnitResponse = {
  /**
   * total units of trade asset
   */
  units: string;
  /**
   * total depth of trade asset
   */
  depth: string;
  /**
   * trade account asset with "~" separator
   */
  asset: string;
};

export type TradeUnitsResponse = Array<TradeUnitResponse>;

export type TradeAccountsResponse = Array<TradeAccountResponse>;

export type TxSignersResponse = {
  out_txs: Array<Tx>;
  /**
   * the thorchain height at which the outbound was finalised
   */
  finalised_height?: number;
  tx: ObservedTx;
  txs: Array<ObservedTx>;
  actions: Array<TxOutItem>;
  /**
   * the thorchain height at which the inbound reached consensus
   */
  consensus_height?: number;
  updated_vault?: boolean;
  reverted?: boolean;
  /**
   * the thorchain height for which the outbound was scheduled
   */
  outbound_height?: number;
  tx_id?: string;
};

export type VaultsResponse = Array<Vault>;

export type KeysignResponse = {
  keysign: {
    /**
     * the block(s) in which a tx out item is scheduled to be signed and moved from the scheduled outbound queue to the outbound queue
     */
    height?: number;
    tx_array: Array<TxOutItem>;
  };
  signature: string;
};

export type SwapperCloutResponse = {
  /**
   * address associated with this clout account
   */
  address: string;
  /**
   * clout score, which is the amount of rune spent on swap fees
   */
  score?: string;
  /**
   * amount of clout that has been reclaimed in total over time (observed clout spent)
   */
  reclaimed?: string;
  /**
   * amount of clout that has been spent in total over time
   */
  spent?: string;
  /**
   * last block height that clout was spent
   */
  last_spent_height?: number;
  /**
   * last block height that clout was reclaimed
   */
  last_reclaim_height?: number;
};

export type QuoteSaverDepositResponse = {
  /**
   * the inbound address for the transaction on the source chain
   */
  inbound_address: string;
  /**
   * the number of thorchain blocks the outbound will be delayed
   */
  outbound_delay_blocks?: number;
  /**
   * expiration timestamp in unix seconds
   */
  expiry: number;
  /**
   * generated memo for the deposit
   */
  memo: string;
  /**
   * the EVM chain router contract address
   */
  router?: string;
  /**
   * static warning message
   */
  warning: string;
  /**
   * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
   */
  recommended_min_amount_in?: string;
  /**
   * same as expected_amount_deposit, to be deprecated in favour of expected_amount_deposit
   */
  expected_amount_out?: string;
  /**
   * the approximate number of source chain blocks required before processing
   */
  inbound_confirmation_blocks?: number;
  /**
   * the approximate seconds for block confirmations required before processing
   */
  inbound_confirmation_seconds?: number;
  /**
   * the approximate seconds for the outbound delay before it will be sent
   */
  outbound_delay_seconds?: number;
  fees: QuoteFees;
  /**
   * chain specific quote notes
   */
  notes: string;
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  /**
   * the amount of the target asset the user can expect to deposit after fees
   */
  expected_amount_deposit: string;
  /**
   * the recommended gas rate to use for the inbound to ensure timely confirmation
   */
  recommended_gas_rate: string;
  /**
   * the units of the recommended gas rate
   */
  gas_rate_units: string;
};

export type QuoteLoanCloseResponse = {
  /**
   * Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
   */
  dust_threshold?: string;
  /**
   * the recommended gas rate to use for the inbound to ensure timely confirmation
   */
  recommended_gas_rate?: string;
  /**
   * generated memo for the loan close
   */
  memo: string;
  /**
   * the amount of collateral asset the user can expect to receive after fees in 1e8 decimals
   */
  expected_amount_out: string;
  /**
   * The approximate number of seconds taken by the streaming swaps involved in the repayment process.
   */
  streaming_swap_seconds: number;
  /**
   * The total expected duration for a repayment, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
   */
  total_repay_seconds: number;
  /**
   * chain specific quote notes
   */
  notes: string;
  /**
   * the approximate seconds for block confirmations required before processing
   */
  inbound_confirmation_seconds?: number;
  fees: QuoteFees;
  /**
   * The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
   */
  recommended_min_amount_in?: string;
  /**
   * The quantity of the repayment asset to be sent by the user, calculated as the desired percentage of the loan's value, expressed in units of 1e8
   */
  expected_amount_in: string;
  /**
   * the approximate number of source chain blocks required before processing
   */
  inbound_confirmation_blocks?: number;
  /**
   * the approximate seconds for the outbound delay before it will be sent
   */
  outbound_delay_seconds: number;
  /**
   * the EVM chain router contract address
   */
  router?: string;
  /**
   * expiration timestamp in unix seconds
   */
  expiry: number;
  /**
   * the units of the recommended gas rate
   */
  gas_rate_units?: string;
  /**
   * the expected amount of TOR debt decrease on the loan
   */
  expected_debt_repaid: string;
  /**
   * the number of thorchain blocks the outbound will be delayed
   */
  outbound_delay_blocks: number;
  /**
   * static warning message
   */
  warning: string;
  /**
   * the expected amount of collateral decrease on the loan
   */
  expected_collateral_withdrawn: string;
  /**
   * The number of blocks involved in the streaming swaps during the repayment process.
   */
  streaming_swap_blocks: number;
  /**
   * the inbound address for the transaction on the source chain
   */
  inbound_address?: string;
};

export type ThornameAlias = {
  chain?: string;
  address?: string;
};

export type DerivedPoolsResponse = Array<DerivedPool>;

export type NetworkResponse = {
  /**
   * the rune price in tor
   */
  rune_price_in_tor: string;
  /**
   * total reserve RUNE
   */
  total_reserve: string;
  /**
   * Sum of the gas the network has spent to send outbounds
   */
  gas_spent_rune: string;
  /**
   * Current outbound fee multiplier, in basis points
   */
  outbound_fee_multiplier?: string;
  /**
   * total amount of RUNE awarded to node operators
   */
  bond_reward_rune: string;
  /**
   * total bonded RUNE
   */
  total_bond_units: string;
  /**
   * Sum of the gas withheld from users to cover outbound gas
   */
  gas_withheld_rune: string;
  /**
   * the thorname register fee in rune, converted from the TNSRegisterFeeUSD mimir (after USD fees are enabled)
   */
  tns_register_fee_rune: string;
  /**
   * the tor price in rune
   */
  tor_price_in_rune: string;
  /**
   * effective security bond used to determine maximum pooled RUNE
   */
  effective_security_bond: string;
  /**
   * Returns true if there exist RetiringVaults which have not finished migrating funds to new ActiveVaults
   */
  vaults_migrating: boolean;
  /**
   * the thorname fee per block in rune, converted from the TNSFeePerBlockUSD mimir (after USD fees are enabled)
   */
  tns_fee_per_block_rune: string;
  /**
   * the outbound transaction fee in rune, converted from the NativeOutboundFeeUSD mimir (after USD fees are enabled)
   */
  native_outbound_fee_rune: string;
  /**
   * the native transaction fee in rune, converted from the NativeTransactionFeeUSD mimir (after USD fees are enabled)
   */
  native_tx_fee_rune: string;
};

export type KeygenMetricsResponse = Array<KeygenMetric>;

/**
 * optional block height, defaults to current tip
 */
export type ParameterqueryHeight = number;

export type Parameterhash = string;

export type Parameterasset = string;

export type Parameteraddress = string;

export type Parametername = string;

export type ParameterpathHeight = number;

export type Parameterpubkey = string;

export type Parameterchain = string;

export type Parameterinvariant = string;

export type PoolsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type PoolsResponse2 = PoolsResponse;

export type PoolsError = unknown;

export type RuneProvidersData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type RuneProvidersResponse = RUNEProvidersResponse;

export type RuneProvidersError = unknown;

export type TxStatusData = {
  path: {
    hash: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TxStatusResponse2 = TxStatusResponse;

export type TxStatusError = unknown;

export type QueueData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type QueueResponse2 = QueueResponse;

export type QueueError = unknown;

export type QueueOutboundData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type QueueOutboundResponse = OutboundResponse;

export type QueueOutboundError = unknown;

export type InvariantsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type InvariantsResponse2 = InvariantsResponse;

export type InvariantsError = unknown;

export type BlockData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type BlockResponse2 = BlockResponse;

export type BlockError = unknown;

export type RuneProviderData = {
  path: {
    address: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type RuneProviderResponse = RUNEProvider;

export type RuneProviderError = unknown;

export type TradeUnitData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TradeUnitResponse2 = TradeUnitResponse;

export type TradeUnitError = unknown;

export type MimirNodeData = {
  path: {
    address: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MimirNodeResponse = MimirResponse;

export type MimirNodeError = unknown;

export type QuotesaverdepositData = {
  query?: {
    /**
     * the source asset amount in 1e8 decimals
     */
    amount?: number;
    /**
     * the asset to deposit
     */
    asset?: string;
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type QuotesaverdepositResponse = QuoteSaverDepositResponse;

export type QuotesaverdepositError = unknown;

export type QuoteloancloseData = {
  query?: {
    /**
     * the asset used to repay the loan
     */
    from_asset?: string;
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
    /**
     * the owner of the loan collateral
     */
    loan_owner?: string;
    /**
     * the minimum amount of the target asset to accept
     */
    min_out?: string;
    /**
     * the basis points of the existing position to repay
     */
    repay_bps?: number;
    /**
     * the collateral asset of the loan
     */
    to_asset?: string;
  };
};

export type QuoteloancloseResponse = QuoteLoanCloseResponse;

export type QuoteloancloseError = unknown;

export type SaversData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type SaversResponse2 = SaversResponse;

export type SaversError = unknown;

export type AsgardData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type AsgardResponse = VaultsResponse;

export type AsgardError = unknown;

export type VaultPubkeysData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type VaultPubkeysResponse2 = VaultPubkeysResponse;

export type VaultPubkeysError = unknown;

export type OutboundFeesData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type OutboundFeesResponse2 = OutboundFeesResponse;

export type OutboundFeesError = unknown;

export type TradeUnitsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TradeUnitsResponse2 = TradeUnitsResponse;

export type TradeUnitsError = unknown;

export type InvariantData = {
  path: {
    invariant: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type InvariantResponse2 = InvariantResponse;

export type InvariantError = unknown;

export type DpoolData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type DpoolResponse = DerivedPool;

export type DpoolError = unknown;

export type UpgradeProposalData = {
  path: {
    name: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type UpgradeProposalResponse2 = UpgradeProposal;

export type UpgradeProposalError = unknown;

export type RagnarokData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type RagnarokResponse = boolean;

export type RagnarokError = unknown;

export type MimirKeyData = {
  path: {
    /**
     * the mimir key to lookup
     */
    key: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MimirKeyResponse = number;

export type MimirKeyError = unknown;

export type SaverData = {
  path: {
    address: string;
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type SaverResponse2 = Saver;

export type SaverError = unknown;

export type TxSignersData = {
  path: {
    hash: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TxSignersResponse2 = TxDetailsResponse;

export type TxSignersError = unknown;

export type NetworkData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type NetworkResponse2 = NetworkResponse;

export type NetworkError = unknown;

export type UpgradeVotesData = {
  path: {
    name: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type UpgradeVotesResponse2 = UpgradeVotesResponse;

export type UpgradeVotesError = unknown;

export type StreamSwapsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type StreamSwapsResponse = StreamingSwapsResponse;

export type StreamSwapsError = unknown;

export type KeysignData = {
  path: {
    height: number;
  };
};

export type KeysignResponse2 = KeysignResponse;

export type KeysignError = unknown;

export type KeygenPubkeyData = {
  path: {
    height: number;
    pubkey: string;
  };
};

export type KeygenPubkeyResponse = KeygenResponse;

export type KeygenPubkeyError = unknown;

export type QuoteswapData = {
  query?: {
    /**
     * the affiliate (address or thorname)
     */
    affiliate?: string;
    /**
     * the affiliate fee in basis points
     */
    affiliate_bps?: number;
    /**
     * the source asset amount in 1e8 decimals
     */
    amount?: number;
    /**
     * the destination address, required to generate memo
     */
    destination?: string;
    /**
     * the source asset
     */
    from_asset?: string;
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
    /**
     * the refund address, refunds will be sent here if the swap fails
     */
    refund_address?: string;
    /**
     * the interval in which streaming swaps are swapped
     */
    streaming_interval?: number;
    /**
     * the quantity of swaps within a streaming swap
     */
    streaming_quantity?: number;
    /**
     * the target asset
     */
    to_asset?: string;
    /**
     * the maximum basis points from the current feeless swap price to set the limit in the generated memo
     */
    tolerance_bps?: number;
  };
};

export type QuoteswapResponse = QuoteSwapResponse;

export type QuoteswapError = unknown;

export type MimirAdminData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MimirAdminResponse = MimirResponse;

export type MimirAdminError = unknown;

export type PingResponse = {
  ping?: string;
};

export type PingError = unknown;

export type RunePoolData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type RunePoolResponse = RUNEPoolResponse;

export type RunePoolError = unknown;

export type YggdrasilData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type YggdrasilResponse = YggdrasilVaultsResponse;

export type YggdrasilError = unknown;

export type SwapperCloutData = {
  path: {
    address: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type SwapperCloutResponse2 = SwapperCloutResponse;

export type SwapperCloutError = unknown;

export type TradeAccountData = {
  path: {
    address: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TradeAccountResponse2 = TradeAccountResponse;

export type TradeAccountError = unknown;

export type TradeAccountsData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TradeAccountsResponse2 = TradeAccountsResponse;

export type TradeAccountsError = unknown;

export type MetricsKeygenData = {
  path: {
    pubkey: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MetricsKeygenResponse = KeygenMetricsResponse;

export type MetricsKeygenError = unknown;

export type MimirNodesData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MimirNodesResponse2 = MimirNodesResponse;

export type MimirNodesError = unknown;

export type QuoteloanopenData = {
  query?: {
    /**
     * the affiliate (address or thorname)
     */
    affiliate?: string;
    /**
     * the affiliate fee in basis points
     */
    affiliate_bps?: number;
    /**
     * the collateral asset amount in 1e8 decimals
     */
    amount?: number;
    /**
     * the destination address, required to generate memo
     */
    destination?: string;
    /**
     * the collateral asset
     */
    from_asset?: string;
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
    /**
     * the minimum amount of the target asset to accept
     */
    min_out?: string;
    /**
     * the target asset to receive (loan denominated in TOR regardless)
     */
    to_asset?: string;
  };
};

export type QuoteloanopenResponse = QuoteLoanOpenResponse;

export type QuoteloanopenError = unknown;

export type QueueSwapData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type QueueSwapResponse = SwapQueueResponse;

export type QueueSwapError = unknown;

export type PoolData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type PoolResponse2 = Pool;

export type PoolError = unknown;

export type BorrowerData = {
  path: {
    address: string;
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type BorrowerResponse2 = Borrower;

export type BorrowerError = unknown;

export type TxSignersOldData = {
  path: {
    hash: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TxSignersOldResponse = TxSignersResponse;

export type TxSignersOldError = unknown;

export type NodesData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type NodesResponse2 = NodesResponse;

export type NodesError = unknown;

export type InboundAddressesData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type InboundAddressesResponse2 = InboundAddressesResponse;

export type InboundAddressesError = unknown;

export type LastblockData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type LastblockResponse = LastBlockResponse;

export type LastblockError = unknown;

export type VersionData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type VersionResponse2 = VersionResponse;

export type VersionError = unknown;

export type MimirData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MimirResponse2 = MimirResponse;

export type MimirError = unknown;

export type TxStagesData = {
  path: {
    hash: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TxStagesResponse2 = TxStagesResponse;

export type TxStagesError = unknown;

export type StreamSwapData = {
  path: {
    hash: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type StreamSwapResponse = StreamingSwap;

export type StreamSwapError = unknown;

export type QueueScheduledData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type QueueScheduledResponse = ScheduledResponse;

export type QueueScheduledError = unknown;

export type PoolslipData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type PoolslipResponse = PoolSlipResponse;

export type PoolslipError = unknown;

export type DpoolsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type DpoolsResponse = DerivedPoolsResponse;

export type DpoolsError = unknown;

export type LiquidityProvidersData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type LiquidityProvidersResponse2 = LiquidityProvidersResponse;

export type LiquidityProvidersError = unknown;

export type VaultData = {
  path: {
    pubkey: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type VaultResponse2 = Vault;

export type VaultError = unknown;

export type UpgradeProposalsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type UpgradeProposalsResponse2 = UpgradeProposalsResponse;

export type UpgradeProposalsError = unknown;

export type OutboundFeeAssetData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type OutboundFeeAssetResponse = OutboundFeesResponse;

export type OutboundFeeAssetError = unknown;

export type MetricsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type MetricsResponse2 = MetricsResponse;

export type MetricsError = unknown;

export type QuotesaverwithdrawData = {
  query?: {
    /**
     * the address for the position
     */
    address?: string;
    /**
     * the asset to withdraw
     */
    asset?: string;
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
    /**
     * the basis points of the existing position to withdraw
     */
    withdraw_bps?: number;
  };
};

export type QuotesaverwithdrawResponse = QuoteSaverWithdrawResponse;

export type QuotesaverwithdrawError = unknown;

export type ThornameData = {
  path: {
    /**
     * the thornode to lookup
     */
    name: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type ThornameResponse2 = Thorname;

export type ThornameError = unknown;

export type PoolslipsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type PoolslipsResponse = PoolSlipResponse;

export type PoolslipsError = unknown;

export type BorrowersData = {
  path: {
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type BorrowersResponse2 = BorrowersResponse;

export type BorrowersError = unknown;

export type NodeData = {
  path: {
    address: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type NodeResponse2 = Node;

export type NodeError = unknown;

export type LastblockChainData = {
  path: {
    chain: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type LastblockChainResponse = LastBlockResponse;

export type LastblockChainError = unknown;

export type ConstantsData = {
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type ConstantsResponse2 = ConstantsResponse;

export type ConstantsError = unknown;

export type BanData = {
  path: {
    address: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type BanResponse2 = BanResponse;

export type BanError = unknown;

export type KeysignPubkeyData = {
  path: {
    height: number;
    pubkey: string;
  };
};

export type KeysignPubkeyResponse = KeysignResponse;

export type KeysignPubkeyError = unknown;

export type LiquidityProviderData = {
  path: {
    address: string;
    asset: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type LiquidityProviderResponse2 = LiquidityProvider;

export type LiquidityProviderError = unknown;

export type TxData = {
  path: {
    hash: string;
  };
  query?: {
    /**
     * optional block height, defaults to current tip
     */
    height?: number;
  };
};

export type TxResponse2 = TxResponse;

export type TxError = unknown;
