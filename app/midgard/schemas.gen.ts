// This file is auto-generated by @hey-api/openapi-ts

export const ActionSchema = {
    description: 'action details among with related transactions',
    properties: {
        date: {
            description: 'Int64, nano timestamp of the block at which the action was registered',
            type: 'string'
        },
        height: {
            description: 'Int64, height of the block at which the action was registered',
            type: 'string'
        },
        in: {
            description: 'Inbound transactions related to the action',
            items: {
                '$ref': '#/components/schemas/Transaction'
            },
            type: 'array'
        },
        metadata: {
            '$ref': '#/components/schemas/Metadata'
        },
        out: {
            description: 'Outbound transactions related to the action',
            items: {
                '$ref': '#/components/schemas/Transaction'
            },
            type: 'array'
        },
        pools: {
            description: 'Pools involved in the action',
            items: {
                type: 'string'
            },
            type: 'array'
        },
        status: {
            description: `Indicates if the action is completed or if related outbound transactions are still
pending.
`,
            enum: ['success', 'pending'],
            type: 'string'
        },
        type: {
            description: 'Type of action',
            enum: ['swap', 'addLiquidity', 'withdraw', 'donate', 'refund', 'switch', 'thorname', 'send', 'runePoolDeposit', 'runePoolWithdraw'],
            type: 'string'
        }
    },
    required: ['pools', 'type', 'status', 'in', 'out', 'date', 'height', 'metadata'],
    type: 'object'
} as const;

export const ActionMetaSchema = {
    description: 'action query metadata',
    properties: {
        nextPageToken: {
            description: `Int64, The last action event_id that can be used for pagination. 
This token is needed to be given for next page.
`,
            type: 'string'
        },
        prevPageToken: {
            description: `Int64, The first action event_id that can be used for previous pagination.
This token is needed to be given for previous page.
`,
            type: 'string'
        }
    },
    required: ['nextPageToken', 'prevPageToken'],
    type: 'object'
} as const;

export const AddLiquidityMetadataSchema = {
    properties: {
        affiliateAddress: {
            description: 'Affiliate fee address of the addLiquidity',
            type: 'string'
        },
        affiliateFee: {
            description: 'Int64 (Basis points, 0-1000, where 1000=10%)',
            type: 'string'
        },
        liquidityUnits: {
            description: `Int64, amount of liquidity units assigned to the member as result of the liquidity
deposit
`,
            type: 'string'
        },
        memo: {
            description: 'Transaction memo of the addLiquidity action',
            type: 'string'
        }
    },
    required: ['liquidityUnits', 'memo', 'affiliateAddress', 'affiliateFee'],
    type: 'object'
} as const;

export const BalanceSchema = {
    properties: {
        coins: {
            '$ref': '#/components/schemas/Coins'
        },
        date: {
            description: 'full timestamp (nanoseconds since 1970) of the block at which the returned balance snapshot was valid',
            example: '946684801000000000',
            type: 'string'
        },
        height: {
            description: 'height of the block at which the returned balance snapshot was valid',
            example: '2000000',
            type: 'string'
        }
    },
    required: ['height', 'date', 'coins'],
    type: 'object'
} as const;

export const BlockRewardsSchema = {
    properties: {
        blockReward: {
            type: 'string'
        },
        bondReward: {
            type: 'string'
        },
        poolReward: {
            type: 'string'
        }
    },
    required: ['blockReward', 'bondReward', 'poolReward'],
    type: 'object'
} as const;

export const BondMetadataSchema = {
    properties: {
        fee: {
            description: 'node operator fee',
            type: 'string'
        },
        memo: {
            description: 'Transaction memo of bond event',
            type: 'string'
        },
        nodeAddress: {
            description: 'node address',
            type: 'string'
        },
        provider: {
            description: 'bond provider address',
            type: 'string'
        }
    },
    required: ['memo', 'nodeAddress'],
    type: 'object'
} as const;

export const BondMetricsSchema = {
    properties: {
        averageActiveBond: {
            description: 'Int64(e8), Average bond of active nodes',
            type: 'string'
        },
        averageStandbyBond: {
            description: 'Int64(e8), Average bond of standby nodes',
            type: 'string'
        },
        bondHardCap: {
            description: 'Int64(e8), Highest effective bond for nodes',
            type: 'string'
        },
        maximumActiveBond: {
            description: 'Int64(e8), Maxinum bond of active nodes',
            type: 'string'
        },
        maximumStandbyBond: {
            description: 'Int64(e8), Maximum bond of standby nodes',
            type: 'string'
        },
        medianActiveBond: {
            description: 'Int64(e8), Median bond of active nodes',
            type: 'string'
        },
        medianStandbyBond: {
            description: 'Int64(e8), Median bond of standby nodes',
            type: 'string'
        },
        minimumActiveBond: {
            description: 'Int64(e8), Minimum bond of active nodes',
            type: 'string'
        },
        minimumStandbyBond: {
            description: 'Int64(e8), Minimum bond of standby nodes',
            type: 'string'
        },
        totalActiveBond: {
            description: 'Int64(e8), Total bond of active nodes',
            type: 'string'
        },
        totalStandbyBond: {
            description: 'Int64(e8), Total bond of standby nodes',
            type: 'string'
        }
    },
    required: ['totalActiveBond', 'averageActiveBond', 'medianActiveBond', 'minimumActiveBond', 'maximumActiveBond', 'bondHardCap', 'totalStandbyBond', 'averageStandbyBond', 'medianStandbyBond', 'minimumStandbyBond', 'maximumStandbyBond'],
    type: 'object'
} as const;

export const BorrowerDetailsSchema = {
    properties: {
        pools: {
            description: 'List details of all the loans identified with the given address',
            items: {
                '$ref': '#/components/schemas/BorrowerPool'
            },
            type: 'array'
        }
    },
    required: ['pools'],
    type: 'object'
} as const;

export const BorrowerPoolSchema = {
    properties: {
        collateral_asset: {
            description: 'The asset that the borrower used as collateral',
            type: 'string'
        },
        collateral_deposited: {
            description: 'Int64(e8), The total amount of collateral that user deposited',
            type: 'string'
        },
        collateral_withdrawn: {
            description: 'Int64(e8), The total amount of collateral the system paid back to the user',
            type: 'string'
        },
        debt_issued_tor: {
            description: 'Int64(e8), The total amount of debt issued as debt for user. denominated in TOR.',
            type: 'string'
        },
        debt_repaid_tor: {
            description: 'Int64(e8), The total amount of debt that the user paid back. denominated in TOR.',
            type: 'string'
        },
        last_open_loan_timestamp: {
            description: 'Int64, Unix timestamp for the last time borrower opened a loan',
            type: 'string'
        },
        last_repay_loan_timestamp: {
            description: 'Int64, Unix timestamp for the last time borrower repayment occurred',
            type: 'string'
        },
        target_assets: {
            items: {
                description: 'All target assets that the user used as debt target',
                example: 'ETH.ETH',
                type: 'string'
            },
            type: 'array'
        }
    },
    required: ['collateral_asset', 'target_assets', 'debt_issued_tor', 'debt_repaid_tor', 'collateral_deposited', 'collateral_withdrawn', 'last_open_loan_timestamp', 'last_repay_loan_timestamp'],
    type: 'object'
} as const;

export const BorrowersSchema = {
    items: {
        description: 'Borrower address',
        example: 'tbnb1fj2lqj8dvr5pumfchc7ntlfqd2v6zdxqwjewf5',
        type: 'string'
    },
    type: 'array'
} as const;

export const ChurnItemSchema = {
    properties: {
        date: {
            description: 'full timestamp (nanoseconds since 1970) of the block at which the churn occurred',
            example: '946684801000000000',
            type: 'string'
        },
        height: {
            description: 'height of the block at which the churn occurred',
            example: '2000000',
            type: 'string'
        }
    },
    required: ['height', 'date'],
    type: 'object'
} as const;

export const ChurnsSchema = {
    items: {
        '$ref': '#/components/schemas/ChurnItem'
    },
    type: 'array'
} as const;

export const CoinSchema = {
    description: 'Represents a digital currency amount',
    properties: {
        amount: {
            description: 'Int64(e8), asset Amount.',
            type: 'string'
        },
        asset: {
            description: 'Asset in CHAIN.SYMBOL format',
            type: 'string'
        }
    },
    required: ['asset', 'amount'],
    type: 'object'
} as const;

export const CoinsSchema = {
    items: {
        '$ref': '#/components/schemas/Coin'
    },
    type: 'array'
} as const;

export const DepthHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/DepthHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/DepthHistoryMeta'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const DepthHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/DepthHistoryItem'
    },
    type: 'array'
} as const;

export const DepthHistoryItemSchema = {
    properties: {
        assetDepth: {
            description: 'Int64(e8), the amount of Asset in the pool at the end of the interval',
            type: 'string'
        },
        assetPrice: {
            description: 'Float, price of asset in rune. I.e. rune amount / asset amount',
            type: 'string'
        },
        assetPriceUSD: {
            description: 'Float, the price of asset in USD (based on the deepest USD pool).',
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        liquidityUnits: {
            description: 'Int64, Liquidity Units in the pool at the end of the interval',
            type: 'string'
        },
        luvi: {
            description: `Float, The liquidity unit value index. Sqrt(assetDepth * runeDepth)/liquidity units
`,
            type: 'string'
        },
        membersCount: {
            description: 'Int64, Number of liquidity members in the pool at the end of the interval',
            type: 'string'
        },
        runeDepth: {
            description: 'Int64(e8), the amount of Rune in the pool at the end of the interval',
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        synthSupply: {
            description: 'Int64, Synth supply in the pool at the end of the interval',
            type: 'string'
        },
        synthUnits: {
            description: 'Int64, Synth Units in the pool at the end of the interval',
            type: 'string'
        },
        units: {
            description: `Int64, Total Units (synthUnits + liquidityUnits) in the pool at the end of the interval
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'assetDepth', 'runeDepth', 'assetPrice', 'assetPriceUSD', 'liquidityUnits', 'membersCount', 'synthUnits', 'synthSupply', 'units', 'luvi'],
    type: 'object'
} as const;

export const DepthHistoryItemPoolSchema = {
    properties: {
        pool: {
            description: 'asset for the given pool',
            type: 'string'
        },
        totalDepth: {
            description: `Int64(e8) in rune, the total value in the pool (both assets and rune) at the end of the interval.
Note: this is twice of the pool's Rune depth. (as pools are symmetrically balance)
`,
            type: 'string'
        }
    },
    required: ['pool', 'totalDepth'],
    type: 'object'
} as const;

export const DepthHistoryMetaSchema = {
    properties: {
        endAssetDepth: {
            description: `Int64(e8), the amount of Asset in the pool at the end of the interval at time endTime
`,
            type: 'string'
        },
        endLPUnits: {
            description: 'Int64, Liquidity Units in the pool at the end of the interval at time endTime',
            type: 'string'
        },
        endMemberCount: {
            description: 'Int64, Number of liquidity members in the pool at the end of the interval at time endTime',
            type: 'string'
        },
        endRuneDepth: {
            description: `Int64(e8), the amount of Rune in the pool at the end of the interval at time endTime
`,
            type: 'string'
        },
        endSynthUnits: {
            description: 'Int64, Synth Units in the pool at the end of the interval at time endTime',
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        luviIncrease: {
            description: `Float, The liquidity unit value index increase between startTime and endTime
`,
            type: 'string'
        },
        priceShiftLoss: {
            description: 'Float, The impermanent loss between the first and last depth item',
            type: 'string'
        },
        startAssetDepth: {
            description: `Int64(e8), the amount of Asset in the pool at the start of the interval at time
startTime
`,
            type: 'string'
        },
        startLPUnits: {
            description: `Int64, Liquidity Units in the pool at the start of the interval at time startTime
`,
            type: 'string'
        },
        startMemberCount: {
            description: `Int64, Number of liquidity member in the pool at the start of the interval at time startTime
`,
            type: 'string'
        },
        startRuneDepth: {
            description: `Int64(e8), the amount of Rune in the pool at the start of the interval at time startTime
`,
            type: 'string'
        },
        startSynthUnits: {
            description: `Int64, Synth Units in the pool at the start of the interval at time startTime
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'priceShiftLoss', 'luviIncrease', 'startAssetDepth', 'startRuneDepth', 'startLPUnits', 'startMemberCount', 'startSynthUnits', 'endAssetDepth', 'endRuneDepth', 'endLPUnits', 'endMemberCount', 'endSynthUnits'],
    type: 'object'
} as const;

export const EarningsHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/EarningsHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/EarningsHistoryItem'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const EarningsHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/EarningsHistoryItem'
    },
    type: 'array'
} as const;

export const EarningsHistoryItemSchema = {
    properties: {
        avgNodeCount: {
            description: 'float64, Average amount of active nodes during the time interval',
            type: 'string'
        },
        blockRewards: {
            description: 'Int64(e8), Total block rewards emitted during the time interval',
            type: 'string'
        },
        bondingEarnings: {
            description: 'Int64(e8), Share of earnings sent to nodes during the time interval',
            type: 'string'
        },
        earnings: {
            description: `Int64(e8), System income generated during the time interval. It is the sum of
liquidity fees and block rewards
`,
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of interval in unix timestamp',
            type: 'string'
        },
        liquidityEarnings: {
            description: 'Int64(e8), Share of earnings sent to pools during the time interval',
            type: 'string'
        },
        liquidityFees: {
            description: `Int64(e8), Total liquidity fees, converted to RUNE, collected during the time interval
`,
            type: 'string'
        },
        pools: {
            description: 'Earnings data for each pool for the time interval',
            items: {
                '$ref': '#/components/schemas/EarningsHistoryItemPool'
            },
            type: 'array'
        },
        runePriceUSD: {
            description: `Float, the price of Rune based on the deepest USD pool at the end of the interval.
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of interval in unix timestamp',
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'liquidityFees', 'blockRewards', 'earnings', 'bondingEarnings', 'liquidityEarnings', 'avgNodeCount', 'runePriceUSD', 'pools'],
    type: 'object'
} as const;

export const EarningsHistoryItemPoolSchema = {
    description: 'pool earnings data during the time interval',
    properties: {
        assetLiquidityFees: {
            description: "Int64(e8), liquidity fees collected in the pool's asset",
            type: 'string'
        },
        earnings: {
            description: 'Int64(e8), total earnings in RUNE (totalLiquidityFees + rewards)',
            type: 'string'
        },
        pool: {
            description: 'asset for the given pool',
            type: 'string'
        },
        rewards: {
            description: `Int64(e8), RUNE amount sent to (positive) or taken from (negative) the pool as
a result of balancing it's share of system income each block
`,
            type: 'string'
        },
        runeLiquidityFees: {
            description: 'Int64(e8), liquidity fees collected in RUNE',
            type: 'string'
        },
        saverEarning: {
            description: `Int64(e8), total saver reward collected by the pool, shown in pool's ASSET
`,
            type: 'string'
        },
        totalLiquidityFeesRune: {
            description: `Int64(e8), total liquidity fees (assetFees + runeFees) collected, shown in RUNE
`,
            type: 'string'
        }
    },
    required: ['pool', 'assetLiquidityFees', 'runeLiquidityFees', 'totalLiquidityFeesRune', 'saverEarning', 'rewards', 'earnings'],
    type: 'object'
} as const;

export const FailedMetadataSchema = {
    properties: {
        code: {
            description: 'failed transaction code',
            type: 'string'
        },
        memo: {
            description: 'failed transaction memo',
            type: 'string'
        },
        reason: {
            description: 'failed transaction code',
            type: 'string'
        }
    },
    required: ['memo', 'reason', 'code'],
    type: 'object'
} as const;

export const GenesisInfSchema = {
    properties: {
        hash: {
            description: 'Genesis Block hash',
            type: 'string'
        },
        height: {
            description: 'Genesis Block height',
            type: 'integer'
        }
    },
    required: ['height', 'hash'],
    type: 'object'
} as const;

export const HealthSchema = {
    properties: {
        database: {
            description: 'True means healthy, connected to database',
            type: 'boolean'
        },
        genesisInfo: {
            '$ref': '#/components/schemas/GenesisInf'
        },
        inSync: {
            description: 'True means healthy. False means Midgard is still catching up to the chain',
            type: 'boolean'
        },
        lastAggregated: {
            '$ref': '#/components/schemas/HeightTS'
        },
        lastCommitted: {
            '$ref': '#/components/schemas/HeightTS'
        },
        lastFetched: {
            '$ref': '#/components/schemas/HeightTS'
        },
        lastThorNode: {
            '$ref': '#/components/schemas/HeightTS'
        },
        scannerHeight: {
            description: 'Int64, the current block count',
            type: 'string'
        }
    },
    required: ['database', 'scannerHeight', 'inSync', 'lastThorNode', 'lastFetched', 'lastCommitted', 'lastAggregated'],
    type: 'object'
} as const;

export const HeightTSSchema = {
    properties: {
        height: {
            description: 'Block height',
            type: 'integer'
        },
        timestamp: {
            description: 'Block timestamp (seconds since epoch)',
            type: 'integer'
        }
    },
    required: ['height', 'timestamp'],
    type: 'object'
} as const;

export const KnownPoolsSchema = {
    additionalProperties: {
        type: 'string'
    },
    example: {
        'BTC.BTC': 'available'
    },
    type: 'object'
} as const;

export const LiquidityHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/LiquidityHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/LiquidityHistoryItem'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const LiquidityHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/LiquidityHistoryItem'
    },
    type: 'array'
} as const;

export const LiquidityHistoryItemSchema = {
    properties: {
        addAssetLiquidityVolume: {
            description: `Int64(e8), total assets deposited during the time interval.
Denoted in Rune using the price at deposit time.
`,
            type: 'string'
        },
        addLiquidityCount: {
            description: `Int64, number of deposits during the time interval.
`,
            type: 'string'
        },
        addLiquidityVolume: {
            description: `Int64(e8), total of rune and asset deposits.
Denoted in Rune (using the price at deposit time).
`,
            type: 'string'
        },
        addRuneLiquidityVolume: {
            description: `Int64(e8), total Rune deposited during the time interval.
`,
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        net: {
            description: `Int64(e8), net liquidity changes (withdrawals - deposits) during the time interval
`,
            type: 'string'
        },
        runePriceUSD: {
            description: `Float, the price of Rune based on the deepest USD pool at the end of the interval.
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        withdrawAssetVolume: {
            description: `Int64(e8), total assets withdrawn during the time interval.
Denoted in Rune using the price at withdraw time.
`,
            type: 'string'
        },
        withdrawCount: {
            description: `Int64, number of withdraw during the time interval.
`,
            type: 'string'
        },
        withdrawRuneVolume: {
            description: `Int64(e8), total Rune withdrawn during the time interval.
`,
            type: 'string'
        },
        withdrawVolume: {
            description: `Int64(e8), total of rune and asset withdrawals.
Denoted in Rune (using the price at withdraw time).
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'addAssetLiquidityVolume', 'addRuneLiquidityVolume', 'addLiquidityVolume', 'addLiquidityCount', 'withdrawAssetVolume', 'withdrawRuneVolume', 'withdrawVolume', 'withdrawCount', 'net', 'runePriceUSD'],
    type: 'object'
} as const;

export const MemberDetailsSchema = {
    properties: {
        pools: {
            description: 'List details of all the liquidity providers identified with the given address',
            items: {
                '$ref': '#/components/schemas/MemberPool'
            },
            type: 'array'
        }
    },
    required: ['pools'],
    type: 'object'
} as const;

export const MemberPoolSchema = {
    properties: {
        assetAdded: {
            description: 'Int64(e8), total asset added to the pool by member',
            type: 'string'
        },
        assetAddress: {
            description: 'asset address used by the member',
            type: 'string'
        },
        assetDeposit: {
            description: `Int64(e8), total asset that is currently deposited to the pool by member.
This field is same as the \`asset_deposit_value\` field in thornode. Mainly can be used 
for tracking, mainly Growth Percentage
`,
            type: 'string'
        },
        assetPending: {
            description: `Int64(e8), asset sent but not added yet, it will be added when the rune pair arrives
`,
            type: 'string'
        },
        assetWithdrawn: {
            description: 'Int64(e8), total asset withdrawn from the pool by member',
            type: 'string'
        },
        dateFirstAdded: {
            description: 'Int64, Unix timestamp for the first time member deposited into the pool',
            type: 'string'
        },
        dateLastAdded: {
            description: 'Int64, Unix timestamp for the last time member deposited into the pool',
            type: 'string'
        },
        liquidityUnits: {
            description: 'Int64, pool liquidity units that belong the the member',
            type: 'string'
        },
        pool: {
            description: 'Pool rest of the data refers to',
            type: 'string'
        },
        runeAdded: {
            description: 'Int64(e8), total Rune added to the pool by member',
            type: 'string'
        },
        runeAddress: {
            description: 'Rune address used by the member',
            type: 'string'
        },
        runeDeposit: {
            description: `Int64(e8), total Rune that is currently deposited to the pool by member.
This field is same as the \`rune_deposit_value\` field in thornode. Mainly can be used 
for tracking, mainly Growth Percentage
`,
            type: 'string'
        },
        runePending: {
            description: `Int64(e8), Rune sent but not added yet, it will be added when the asset pair arrives
`,
            type: 'string'
        },
        runeWithdrawn: {
            description: 'Int64(e8), total Rune withdrawn from the pool by member',
            type: 'string'
        }
    },
    required: ['pool', 'runeAddress', 'assetAddress', 'liquidityUnits', 'runeDeposit', 'assetDeposit', 'runeAdded', 'assetAdded', 'runePending', 'assetPending', 'runeWithdrawn', 'assetWithdrawn', 'dateFirstAdded', 'dateLastAdded'],
    type: 'object'
} as const;

export const MembersSchema = {
    items: {
        description: 'Member address',
        example: 'tbnb1fj2lqj8dvr5pumfchc7ntlfqd2v6zdxqwjewf5',
        type: 'string'
    },
    type: 'array'
} as const;

export const MetadataSchema = {
    properties: {
        addLiquidity: {
            '$ref': '#/components/schemas/AddLiquidityMetadata'
        },
        bond: {
            '$ref': '#/components/schemas/BondMetadata'
        },
        failed: {
            '$ref': '#/components/schemas/FailedMetadata'
        },
        refund: {
            '$ref': '#/components/schemas/RefundMetadata'
        },
        runePoolDeposit: {
            '$ref': '#/components/schemas/RunePoolDepositMetadata'
        },
        runePoolWithdraw: {
            '$ref': '#/components/schemas/RunePoolWithdrawMetadata'
        },
        send: {
            '$ref': '#/components/schemas/SendMetadata'
        },
        swap: {
            '$ref': '#/components/schemas/SwapMetadata'
        },
        thorname: {
            '$ref': '#/components/schemas/ThornameMetadata'
        },
        withdraw: {
            '$ref': '#/components/schemas/WithdrawMetadata'
        }
    },
    type: 'object'
} as const;

export const NetworkSchema = {
    properties: {
        activeBonds: {
            description: `Array of rune amounts (e8) bonded by each active node.
`,
            items: {
                type: 'string'
            },
            type: 'array'
        },
        activeNodeCount: {
            description: 'Int64, Number of active nodes',
            type: 'string'
        },
        blockRewards: {
            '$ref': '#/components/schemas/BlockRewards'
        },
        bondMetrics: {
            '$ref': '#/components/schemas/BondMetrics'
        },
        bondingAPY: {
            description: `Float, E.g. 0.01 = 1%. Estimate of the compounded bonding earnings based on the current
reserve size, emmission curve, blocks per year and pool share factor =
(WeeklyBondIncome/BondAmount + 1)^52 - 1
`,
            type: 'string'
        },
        liquidityAPY: {
            description: `Float, E.g. 0.01 = 1%. Estimate of the compounded  liquidity provider earnings based
on the current reserve size, emmission curve, blocks per year and pool share factor =
(WeeklyLiquidityIncome/(totalPooledRune*2) + 1)^52 - 1
`,
            type: 'string'
        },
        nextChurnHeight: {
            description: 'Int64, height (block number) of the next churn.',
            type: 'string'
        },
        poolActivationCountdown: {
            description: 'Int64, the remaining time of pool activation (in blocks)',
            type: 'string'
        },
        poolShareFactor: {
            description: `Float [0..1], the ratio which is used to split earnings between liquidity provider and
nodes.
LPIncome = rewards * poolShareFactor ;
BondIncome :=  rewards * (1 - poolShareFactor)
`,
            type: 'string'
        },
        standbyBonds: {
            description: `Array of rune amounts (e8) bonded by each standby node.
`,
            items: {
                type: 'string'
            },
            type: 'array'
        },
        standbyNodeCount: {
            description: `Int64, Number of standby nodes, some of them might become active at the next churn.
`,
            type: 'string'
        },
        totalPooledRune: {
            description: `Int64(e8), total Rune in all pools. Because asset and Rune value is the same amount in
every pool (by definition), the total amount pooled is totalPooledRune*2.
`,
            type: 'string'
        },
        totalReserve: {
            description: 'Int64(e8), Current size of the Reserve.',
            type: 'string'
        }
    },
    required: ['bondMetrics', 'blockRewards', 'activeBonds', 'standbyBonds', 'activeNodeCount', 'standbyNodeCount', 'totalPooledRune', 'totalReserve', 'nextChurnHeight', 'poolActivationCountdown', 'poolShareFactor', 'bondingAPY', 'liquidityAPY'],
    type: 'object'
} as const;

export const NetworkFeesSchema = {
    description: `List of network fees associated to an action. One network fee is charged for each
outbound transaction
`,
    items: {
        '$ref': '#/components/schemas/Coin'
    },
    type: 'array'
} as const;

export const NodeSchema = {
    properties: {
        ed25519: {
            description: 'ed25519 public key',
            example: 'thorpub1addwnpepqgxwdf3ure0pg5fwnpeux3ym9n06267lkres54zwjh4c8048ezhj5024qyr',
            type: 'string'
        },
        nodeAddress: {
            description: 'node thorchain address',
            example: 'thor102y0m3uptg0vvudeyh00r2fnz70wq7d8y7mu2g',
            type: 'string'
        },
        secp256k1: {
            description: 'secp256k1 public key',
            example: 'thorpub1addwnpepqgxwdf3ure0pg5fwnpeux3ym9n06267lkres54zwjh4c8048ezhj5024qyr',
            type: 'string'
        }
    },
    required: ['nodeAddress', 'secp256k1', 'ed25519'],
    type: 'object'
} as const;

export const NodesSchema = {
    items: {
        '$ref': '#/components/schemas/Node'
    },
    type: 'array'
} as const;

export const PoolDetailSchema = {
    properties: {
        annualPercentageRate: {
            description: `Float, Annual Percentage Yield of earning to depth (earning/depth) estimated from a period
(configurable by the period parameter, default is 14) E.g. 0.1 means 10% yearly return.
`,
            type: 'string'
        },
        asset: {
            type: 'string'
        },
        assetDepth: {
            description: 'Int64(e8), the amount of Asset in the pool.',
            type: 'string'
        },
        assetPrice: {
            description: 'Float, price of asset in rune. I.e. rune amount / asset amount.',
            type: 'string'
        },
        assetPriceUSD: {
            description: 'Float, the price of asset in USD (based on the deepest USD pool).',
            type: 'string'
        },
        earnings: {
            description: `Int64(e8), The earning that has been recorded from the pool asset's Liquidity Fees
and Rewards in RUNE. The earnings shown are from the period parameter default being 14 days 
(configurable by the period parameter).
`,
            type: 'string'
        },
        earningsAnnualAsPercentOfDepth: {
            description: `Float, The estimation of earnings during the time interval expanded through a year 
compared to the current pool depth.
E.g. 0.1 means the pool based on this interval earnings can earn 10% of its pool during a year.
`,
            type: 'string'
        },
        liquidityUnits: {
            description: 'Int64, Liquidity Units in the pool.',
            type: 'string'
        },
        lpLuvi: {
            description: `Float, Annual yield estimated (compounding) from a period (default being 14d)
configurable by the period parameter. Calculated from Liquidity Unit Value Index (LUVI).
Due to Impermanent Loss and Synths Leverage this might be negative.
`,
            type: 'string'
        },
        nativeDecimal: {
            description: `Int64, The native decimal number of the pool asset. (If the value is "-1", it means midgard doesn't know the pool native decimal)`,
            type: 'string'
        },
        poolAPY: {
            description: `Float, Annual Percentage Yield of earning to depth (earning/depth) estimated from a period
(configurable by the period parameter, default is 14) E.g. 0.1 means 10% yearly return.
`,
            type: 'string'
        },
        runeDepth: {
            description: 'Int64(e8), the amount of Rune in the pool.',
            type: 'string'
        },
        saversAPR: {
            description: `Float, Annual Return estimated linearly (not compounded) for savers from
a period of typically the last 30 or 100 days (configurable by the period parameter,
default is 14). E.g. 0.1 means 10% yearly return.
If the savers period has not yet been reached, It will show zero instead.
`,
            type: 'string'
        },
        saversDepth: {
            description: 'Int64, Total synth locked in saver vault.',
            type: 'string'
        },
        saversUnits: {
            description: 'Int64, Units tracking savers vault ownership.',
            type: 'string'
        },
        saversYieldShare: {
            description: `Float, the proportion of overall yield that is given to savers based on its size 
(relative to dual side LPs) and the SynthYieldBasisPoints. E.g. 0.1 means 10% of the yield
goes to the savers.
`,
            type: 'string'
        },
        status: {
            description: 'The state of the pool, e.g. Available, Staged.',
            type: 'string'
        },
        synthSupply: {
            description: 'Int64, Synth supply in the pool.',
            type: 'string'
        },
        synthUnits: {
            description: 'Int64, Synth Units in the pool.',
            type: 'string'
        },
        totalCollateral: {
            description: 'Int64, Total collateral of the pool created by the borrowers.',
            type: 'string'
        },
        totalDebtTor: {
            description: 'Int64, Total debt of the pool by the borrowers.',
            type: 'string'
        },
        units: {
            description: 'Int64, Total Units (synthUnits + liquidityUnits) in the pool.',
            type: 'string'
        },
        volume24h: {
            description: `Int64(e8), the total volume of swaps in the last 24h to and from Rune denoted in Rune.
It includes synth mint or burn.
`,
            type: 'string'
        }
    },
    required: ['asset', 'volume24h', 'assetDepth', 'runeDepth', 'assetPrice', 'assetPriceUSD', 'annualPercentageRate', 'poolAPY', 'earnings', 'earningsAnnualAsPercentOfDepth', 'status', 'liquidityUnits', 'synthUnits', 'synthSupply', 'units', 'nativeDecimal', 'saversUnits', 'saversDepth', 'saversAPR', 'totalCollateral', 'totalDebtTor', 'lpLuvi'],
    type: 'object'
} as const;

export const PoolDetailsSchema = {
    items: {
        '$ref': '#/components/schemas/PoolDetail'
    },
    type: 'array'
} as const;

export const PoolStatsDetailSchema = {
    properties: {
        addAssetLiquidityVolume: {
            description: 'Int64(e8), same as history/liquidity_changes:addAssetLiquidityVolume',
            type: 'string'
        },
        addLiquidityCount: {
            description: 'Int64, same as history/liquidity_changes:addLiquidityCount',
            type: 'string'
        },
        addLiquidityVolume: {
            description: 'Int64(e8), same as history/liquidity_changes:addLiquidityVolume',
            type: 'string'
        },
        addRuneLiquidityVolume: {
            description: 'Int64(e8), same as history/liquidity_changes:addRuneLiquidityVolume',
            type: 'string'
        },
        annualPercentageRate: {
            description: "deprecated now it's only showing zero util being deleted.",
            type: 'string'
        },
        asset: {
            type: 'string'
        },
        assetDepth: {
            description: 'Int64(e8), the amount of Asset in the pool',
            type: 'string'
        },
        assetPrice: {
            description: 'Float, price of asset in rune. I.e. rune amount / asset amount',
            type: 'string'
        },
        assetPriceUSD: {
            description: 'Float, the price of asset in USD (based on the deepest USD pool).',
            type: 'string'
        },
        averageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), same as history/swaps:averageSlip
`,
            type: 'string'
        },
        earnings: {
            description: `Int64(e8), The earning that has been recorded from the pool asset's Liquidity Fees
and Rewards in RUNE. The earnings shown are from the period parameter default being 14 days 
(configurable by the period parameter).
`,
            type: 'string'
        },
        earningsAnnualAsPercentOfDepth: {
            description: `Float, The estimation of earnings during the time interval expanded through a year 
compared to the current pool depth.
E.g. 0.1 means the pool based on this interval earnings can earn 10% of its pool during a year.
`,
            type: 'string'
        },
        liquidityUnits: {
            description: 'Int64, Liquidity Units in the pool',
            type: 'string'
        },
        poolAPY: {
            description: "deprecated now it's only showing zero util being deleted.",
            type: 'string'
        },
        runeDepth: {
            description: 'Int64(e8), the amount of Rune in the pool',
            type: 'string'
        },
        saversAPR: {
            description: `Float, Annual Return estimated linearly (not compounded) for savers from
a period of typically the last 30 or 100 days (configurable by the period parameter,
default is 14). E.g. 0.1 means 10% yearly return.
If the savers period has not yet been reached, It will show zero instead.
`,
            type: 'string'
        },
        status: {
            description: 'The state of the pool, e.g. Available, Staged',
            type: 'string'
        },
        swapCount: {
            description: 'Int64, same as history/swaps:totalCount',
            type: 'string'
        },
        swapVolume: {
            description: 'Int64(e8), same as history/swaps:totalVolume',
            type: 'string'
        },
        synthSupply: {
            description: 'Int64, Synth supply in the pool',
            type: 'string'
        },
        synthUnits: {
            description: 'Int64, Synth Units in the pool',
            type: 'string'
        },
        toAssetAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), same as
history/swaps:toAssetAverageSlip
`,
            type: 'string'
        },
        toAssetCount: {
            description: 'Int64, same as history/swaps:toAssetCount',
            type: 'string'
        },
        toAssetFees: {
            description: 'Int64(e8), same as history/swaps:toAssetFees',
            type: 'string'
        },
        toAssetVolume: {
            description: 'Int64(e8), same as history/swaps:toAssetVolume',
            type: 'string'
        },
        toRuneAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), same as
history/swaps:toRuneAverageSlip
`,
            type: 'string'
        },
        toRuneCount: {
            description: 'Int64, same as history/swaps:toRuneCount',
            type: 'string'
        },
        toRuneFees: {
            description: 'Int64(e8), same as history/swaps:toRuneFees',
            type: 'string'
        },
        toRuneVolume: {
            description: 'Int64(e8), same as history/swaps:toRuneVolume',
            type: 'string'
        },
        totalFees: {
            description: 'Int64(e8), same as history/swaps:totalFees',
            type: 'string'
        },
        uniqueMemberCount: {
            description: 'Int64, same as len(history/members?pool=POOL)',
            type: 'string'
        },
        uniqueSwapperCount: {
            description: "Deprecated, it's always 0.",
            type: 'string'
        },
        units: {
            description: 'Int64, Total Units (synthUnits + liquidityUnits) in the pool',
            type: 'string'
        },
        withdrawAssetVolume: {
            description: 'Int64(e8), same as history/liquidity_changes:withdrawAssetVolume',
            type: 'string'
        },
        withdrawCount: {
            description: 'Int64, same as history/liquidity_changes:withdrawCount',
            type: 'string'
        },
        withdrawRuneVolume: {
            description: 'Int64(e8), same as history/liquidity_changes:withdrawRuneVolume',
            type: 'string'
        },
        withdrawVolume: {
            description: 'Int64(e8), same as history/liquidity_changes:withdrawVolume',
            type: 'string'
        }
    },
    required: ['asset', 'status', 'assetPrice', 'assetPriceUSD', 'assetDepth', 'runeDepth', 'liquidityUnits', 'synthUnits', 'synthSupply', 'units', 'toAssetVolume', 'toRuneVolume', 'swapVolume', 'toAssetCount', 'toRuneCount', 'swapCount', 'uniqueSwapperCount', 'toAssetAverageSlip', 'toRuneAverageSlip', 'averageSlip', 'toAssetFees', 'toRuneFees', 'totalFees', 'poolAPY', 'annualPercentageRate', 'earnings', 'earningsAnnualAsPercentOfDepth', 'saversAPR', 'addAssetLiquidityVolume', 'addRuneLiquidityVolume', 'addLiquidityVolume', 'addLiquidityCount', 'withdrawAssetVolume', 'withdrawRuneVolume', 'withdrawVolume', 'withdrawCount', 'uniqueMemberCount'],
    type: 'object'
} as const;

export const RUNEPoolDetailsSchema = {
    description: 'List details of all the RUNEPools identified with the given addresses',
    items: {
        '$ref': '#/components/schemas/RUNEPoolProvider'
    },
    type: 'array'
} as const;

export const RUNEPoolHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/RUNEPoolHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/RUNEPoolHistoryMeta'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const RUNEPoolHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/RUNEPoolHistoryItem'
    },
    type: 'array'
} as const;

export const RUNEPoolHistoryItemSchema = {
    properties: {
        count: {
            description: 'Int64, Number of RUNEPool members in the pool at the end of the interval',
            type: 'string'
        },
        depth: {
            description: 'Int64(e8), The depth in the RUNEPool vault at the end of the interval',
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        units: {
            description: `Int64, Units in the RUNEPool vault at the end of the interval
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'count', 'units'],
    type: 'object'
} as const;

export const RUNEPoolHistoryMetaSchema = {
    properties: {
        endCount: {
            description: 'Int64, Number of RUNEPool member in the RUNEPool vault at the end of the interval at time endTime',
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        endUnits: {
            description: 'Int64,  Units in the RUNEPool vault at the end of the interval at time endTime',
            type: 'string'
        },
        startCount: {
            description: `Int64, Number of RUNEPool member in the RUNEPool vault at the start of the interval at time startTime
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        startUnits: {
            description: `Int64,  Units in the RUNEPool vault at the start of the interval at time startTime
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'startUnits', 'startCount', 'endUnits', 'endCount'],
    type: 'object'
} as const;

export const RUNEPoolProviderSchema = {
    properties: {
        dateFirstAdded: {
            description: 'Int64, Unix timestamp for the first time member deposited into the RUNEPool',
            type: 'string'
        },
        dateLastAdded: {
            description: 'Int64, Unix timestamp for the last time member deposited into the RUNEPool',
            type: 'string'
        },
        runeAdded: {
            description: 'Int64(e8), total asset added in the RUNEPool by member',
            type: 'string'
        },
        runeAddress: {
            description: 'address used by the member',
            type: 'string'
        },
        runeDeposit: {
            description: 'Int64(e8), total asset that is currently deposited by the member',
            type: 'string'
        },
        runeWithdrawn: {
            description: 'Int64(e8), total asset withdrawn from the RUNEPool by the member',
            type: 'string'
        },
        units: {
            description: 'Int64, units that belong the the member',
            type: 'string'
        }
    },
    required: ['runeAddress', 'units', 'runeAdded', 'runeWithdrawn', 'runeDeposit', 'dateFirstAdded', 'dateLastAdded'],
    type: 'object'
} as const;

export const RefundMetadataSchema = {
    properties: {
        affiliateAddress: {
            description: 'Affiliate fee address of the swap, empty if fee swap',
            type: 'string'
        },
        affiliateFee: {
            description: 'Int64 (Basis points, 0-1000, where 1000=10%)',
            type: 'string'
        },
        memo: {
            description: 'Transaction memo of the refund action',
            type: 'string'
        },
        networkFees: {
            '$ref': '#/components/schemas/NetworkFees'
        },
        reason: {
            description: 'Reason for the refund',
            type: 'string'
        },
        txType: {
            description: `The type of the transaction given from its Memo
Type of Transaction type: 
"unknown", "add", "withdraw", "swap", "limitOrder", "outbound", "donate",
"bond", "unbond", "leave", "yggdrasilFund", "yggdrasilReturn", "reserve",
"refund", "migrate", "ragnarok", "switch", "noOp", "consolidate", "thorname",
"loanOpen", "loanRepayment"
`,
            example: 'loanOpen',
            type: 'string'
        }
    },
    required: ['networkFees', 'reason', 'memo', 'affiliateFee', 'affiliateAddress', 'txType'],
    type: 'object'
} as const;

export const ReserveHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/ReserveIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/ReserveMeta'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const ReserveIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/ReserveItem'
    },
    type: 'array'
} as const;

export const ReserveItemSchema = {
    properties: {
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        gasFeeOutbound: {
            description: 'Int64(e8), fee made from outbound',
            type: 'string'
        },
        gasReimbursement: {
            description: 'Int64(e8), RUNE paid to the pool for compensating the gas fees',
            type: 'string'
        },
        networkFee: {
            description: `Int64(e8), RUNE paid to the system on deposit, send messages
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'gasFeeOutbound', 'gasReimbursement', 'networkFee'],
    type: 'object'
} as const;

export const ReserveMetaSchema = {
    properties: {
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        gasFeeOutbound: {
            description: `Int64(e8), fee made from outbound
`,
            type: 'string'
        },
        gasReimbursement: {
            description: `Int64(e8), RUNE paid to the pool for compensating the gas fees
`,
            type: 'string'
        },
        networkFee: {
            description: `Int64(e8), RUNE paid to the system on deposit, send messages
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'gasFeeOutbound', 'gasReimbursement', 'networkFee'],
    type: 'object'
} as const;

export const ReverseTHORNamesSchema = {
    items: {
        description: 'THORName name',
        example: 'myname',
        type: 'string'
    },
    type: 'array'
} as const;

export const RunePoolDepositMetadataSchema = {
    properties: {
        units: {
            description: `Int64, amount of units assigned to the member as result of the 
deposit
`,
            type: 'string'
        }
    },
    required: ['units'],
    type: 'object'
} as const;

export const RunePoolWithdrawMetadataSchema = {
    properties: {
        affiliateAddress: {
            description: 'Transaction affiliate address',
            type: 'string'
        },
        affiliateAmount: {
            description: 'Int64, Transaction affiliate amount in rune',
            type: 'string'
        },
        affiliateBasisPoint: {
            description: 'Transaction affiliate basis point',
            type: 'string'
        },
        basisPoints: {
            description: `Int64 (Basis points, 0-10000, where 10000=100%), percentage of total ownership
withdrawn
`,
            type: 'string'
        },
        units: {
            description: `Int64, amount of units removed from the member as result of the withdrawal
`,
            type: 'string'
        }
    },
    required: ['units', 'basisPoints', 'affiliateAmount', 'affiliateAddress', 'affiliateBasisPoint'],
    type: 'object'
} as const;

export const SaverDetailsSchema = {
    properties: {
        pools: {
            description: 'List details of all the savers identified with the given address',
            items: {
                '$ref': '#/components/schemas/SaverPool'
            },
            type: 'array'
        }
    },
    required: ['pools'],
    type: 'object'
} as const;

export const SaverPoolSchema = {
    properties: {
        assetAdded: {
            description: 'Int64(e8), total asset added in the saver pool by member',
            type: 'string'
        },
        assetAddress: {
            description: 'saver address used by the member',
            type: 'string'
        },
        assetDeposit: {
            description: 'Int64(e8), total asset that is currently deposited by the member',
            type: 'string'
        },
        assetRedeem: {
            description: 'Int64(e8), total asset can be redeemed from the saver pool by member',
            type: 'string'
        },
        assetWithdrawn: {
            description: 'Int64(e8), total asset withdrawn from the saver pool by member',
            type: 'string'
        },
        dateFirstAdded: {
            description: 'Int64, Unix timestamp for the first time member deposited into the saver pool',
            type: 'string'
        },
        dateLastAdded: {
            description: 'Int64, Unix timestamp for the last time member deposited into the saver pool',
            type: 'string'
        },
        pool: {
            description: 'The Pool rest of the data are referring to (only those pools can show up which have a corresponding saver pool)',
            type: 'string'
        },
        saverUnits: {
            description: 'Int64, saver liquidity units that belong the the member',
            type: 'string'
        }
    },
    required: ['pool', 'assetAddress', 'saverUnits', 'assetAdded', 'assetRedeem', 'assetDeposit', 'assetWithdrawn', 'dateFirstAdded', 'dateLastAdded'],
    type: 'object'
} as const;

export const SaversHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/SaversHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/SaversHistoryMeta'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const SaversHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/SaversHistoryItem'
    },
    type: 'array'
} as const;

export const SaversHistoryItemSchema = {
    properties: {
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        saversCount: {
            description: 'Int64, Number of saver members in the pool at the end of the interval',
            type: 'string'
        },
        saversDepth: {
            description: 'Int64(e8), The depth in the savers vault at the end of the interval',
            type: 'string'
        },
        saversUnits: {
            description: `Int64, Savers Units in the saver vault at the end of the interval
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'saversDepth', 'saversCount', 'saversUnits'],
    type: 'object'
} as const;

export const SaversHistoryMetaSchema = {
    properties: {
        endSaversCount: {
            description: 'Int64, Number of savers member in the savers vault at the end of the interval at time endTime',
            type: 'string'
        },
        endSaversDepth: {
            description: `Int64(e8), The depth in the savers vault at the end of the interval at time
endTime
`,
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        endUnits: {
            description: 'Int64, Savers Units in the savers vault at the end of the interval at time endTime',
            type: 'string'
        },
        startSaversCount: {
            description: `Int64, Number of savers member in the savers vault at the start of the interval at time startTime
`,
            type: 'string'
        },
        startSaversDepth: {
            description: `Int64(e8), The depth in savers vault at the start of the interval at time
startTime
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        startUnits: {
            description: `Int64, Savers Units in the savers vault at the start of the interval at time startTime
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'startSaversDepth', 'startUnits', 'startSaversCount', 'endSaversDepth', 'endUnits', 'endSaversCount'],
    type: 'object'
} as const;

export const SendMetadataSchema = {
    properties: {
        memo: {
            description: 'Transaction memo of the send action',
            type: 'string'
        },
        networkFees: {
            '$ref': '#/components/schemas/NetworkFees'
        }
    },
    required: ['networkFees', 'memo'],
    type: 'object'
} as const;

export const StatsDataSchema = {
    properties: {
        addLiquidityCount: {
            description: 'Int64, number of deposits since beginning.',
            type: 'string'
        },
        addLiquidityVolume: {
            description: `Int64(e8), total of deposits since beginning.
`,
            type: 'string'
        },
        dailyActiveUsers: {
            description: "Deprecated, it's always 0.",
            type: 'string'
        },
        monthlyActiveUsers: {
            description: "Deprecated, it's always 0.",
            type: 'string'
        },
        runeDepth: {
            description: 'Int64(e8), current total Rune in the pools.',
            type: 'string'
        },
        runePriceUSD: {
            description: 'Float, the price of Rune based on the deepest USD pool.',
            type: 'string'
        },
        swapCount: {
            description: 'Int64, number of swaps (including synths) since beginning.',
            type: 'string'
        },
        swapCount24h: {
            description: 'Int64(e8), number of swaps (including synths) in the last 24h.',
            type: 'string'
        },
        swapCount30d: {
            description: 'Int64, number of swaps (including synths) in the last 30d.',
            type: 'string'
        },
        swapVolume: {
            description: `Int64(e8), total volume of swaps (including synths) denoted in Rune since beginning.
`,
            type: 'string'
        },
        switchedRune: {
            description: 'Int64(e8), amount of native rune switched from erc20 or bep2 rune.',
            type: 'string'
        },
        synthBurnCount: {
            description: 'Int64, number of swaps from Synth to Rune since beginning.',
            type: 'string'
        },
        synthMintCount: {
            description: 'Int64, number of swaps from Rune to Synth since beginning.',
            type: 'string'
        },
        toAssetCount: {
            description: 'Int64, number of swaps from Rune to Asset since beginning.',
            type: 'string'
        },
        toRuneCount: {
            description: 'Int64, number of swaps from Asset to Rune since beginning.',
            type: 'string'
        },
        uniqueSwapperCount: {
            description: "Deprecated, it's always 0.",
            type: 'string'
        },
        withdrawCount: {
            description: 'Int64, number of withdraws since beginning.',
            type: 'string'
        },
        withdrawVolume: {
            description: `Int64(e8), total of withdraws since beginning.
`,
            type: 'string'
        }
    },
    required: ['runeDepth', 'switchedRune', 'runePriceUSD', 'swapVolume', 'swapCount24h', 'swapCount30d', 'swapCount', 'toAssetCount', 'toRuneCount', 'synthMintCount', 'synthBurnCount', 'dailyActiveUsers', 'monthlyActiveUsers', 'uniqueSwapperCount', 'addLiquidityVolume', 'withdrawVolume', 'addLiquidityCount', 'withdrawCount'],
    type: 'object'
} as const;

export const StreamingSwapMetaSchema = {
    description: 'Streaming Metadata associated with the action if it was streaming swap',
    properties: {
        count: {
            description: 'Int64, Number of swaps events which already happened.',
            type: 'string'
        },
        depositedCoin: {
            '$ref': '#/components/schemas/Coin'
        },
        failedSwapReasons: {
            description: 'Array of failed swaps reasons in streaming swap.',
            items: {
                description: 'The reason why swap got failed',
                type: 'string'
            },
            type: 'array'
        },
        failedSwaps: {
            description: 'Array of failed swaps index in streaming swap.',
            items: {
                description: 'Int64, Failed Swap number',
                type: 'string'
            },
            type: 'array'
        },
        inCoin: {
            '$ref': '#/components/schemas/Coin'
        },
        interval: {
            description: 'Int64, Number of blocks between swpas. (Blocks/Swap) E.g. 1 means every block.',
            type: 'string'
        },
        lastHeight: {
            description: `Int64, The last blockheight the final swap happened (not outbound). This field will be missing until the final swap happens.
`,
            type: 'string'
        },
        outCoin: {
            '$ref': '#/components/schemas/Coin'
        },
        quantity: {
            description: `Int64,  Number of swaps which thorchain is planning to execute. Total count at the end might be less.
`,
            type: 'string'
        }
    },
    required: ['count', 'quantity', 'interval', 'lastHeight', 'inCoin', 'outCoin', 'depositedCoin'],
    type: 'object'
} as const;

export const SwapHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/SwapHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/SwapHistoryItem'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const SwapHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/SwapHistoryItem'
    },
    type: 'array'
} as const;

export const SwapHistoryItemSchema = {
    properties: {
        averageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the weighted average (by count)
of toAssetAverageSlip, toRuneAverageSlip, synthMintAverageSlip, synthRedeemAverageSlip.
Big swaps have the same weight as small swaps.
`,
            type: 'string'
        },
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        fromTradeAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps
from asset to trade asset.
Big swaps have the same weight as small swaps
`,
            type: 'string'
        },
        fromTradeCount: {
            description: 'Int64, count of swaps from trade asset to rune',
            type: 'string'
        },
        fromTradeFees: {
            description: 'Int64(e8), the fees collected from swaps from rune to trade asset (in rune)',
            type: 'string'
        },
        fromTradeVolume: {
            description: 'Int64(e8), volume of swaps from rune to trade asset denoted in rune',
            type: 'string'
        },
        fromTradeVolumeUSD: {
            description: 'Int64(e2), volume of swaps from trade asset to rune denoted in USD price of the rune in each swap',
            type: 'string'
        },
        runePriceUSD: {
            description: `Float, the price of Rune based on the deepest USD pool at the end of the interval.
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        synthMintAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps
from rune to synthetic asset.
Big swaps have the same weight as small swaps
`,
            type: 'string'
        },
        synthMintCount: {
            description: 'Int64, count of rune to synthetic asset swaps',
            type: 'string'
        },
        synthMintFees: {
            description: `Int64(e8), the fees collected from swaps from rune to synthetic asset (in rune)
`,
            type: 'string'
        },
        synthMintVolume: {
            description: 'Int64(e8), volume of swaps from rune to synthetic asset denoted in rune',
            type: 'string'
        },
        synthMintVolumeUSD: {
            description: 'Int64(e2), volume of swaps from rune to synthetic asset denoted in USD price of the rune in each swap',
            type: 'string'
        },
        synthRedeemAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps
from synthetic asset to rune.
Big swaps have the same weight as small swaps
`,
            type: 'string'
        },
        synthRedeemCount: {
            description: 'Int64, count of synthetic asset to rune swaps',
            type: 'string'
        },
        synthRedeemFees: {
            description: `Int64(e8), the fees collected from swaps from synthetic asset to rune (in rune)
`,
            type: 'string'
        },
        synthRedeemVolume: {
            description: 'Int64(e8), volume of swaps from synthetic asset to rune denoted in rune',
            type: 'string'
        },
        synthRedeemVolumeUSD: {
            description: 'Int64(e2), volume of swaps from synthetic asset to rune denoted in USD price of the rune in each swap',
            type: 'string'
        },
        toAssetAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps
from rune to asset.
Big swaps have the same weight as small swaps
`,
            type: 'string'
        },
        toAssetCount: {
            description: 'Int64, count of swaps from rune to asset',
            type: 'string'
        },
        toAssetFees: {
            description: 'Int64(e8), the fees collected from swaps from rune to asset (in rune)',
            type: 'string'
        },
        toAssetVolume: {
            description: 'Int64(e8), volume of swaps from rune to asset denoted in rune',
            type: 'string'
        },
        toAssetVolumeUSD: {
            description: 'Int64(e2), volume of swaps from rune to asset denoted in USD price of the rune in each swap',
            type: 'string'
        },
        toRuneAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps
from asset to rune.
Big swaps have the same weight as small swaps
`,
            type: 'string'
        },
        toRuneCount: {
            description: 'Int64, count of swaps from asset to rune',
            type: 'string'
        },
        toRuneFees: {
            description: 'Int64(e8), the fees collected from swaps from asset to rune (in rune)',
            type: 'string'
        },
        toRuneVolume: {
            description: 'Int64(e8), volume of swaps from asset to rune denoted in rune',
            type: 'string'
        },
        toRuneVolumeUSD: {
            description: 'Int64(e2), volume of swaps from asset to rune denoted in USD price of the rune in each swap',
            type: 'string'
        },
        toTradeAverageSlip: {
            description: `Float64 (Basis points, 0-10000, where 10000=100%), the average slip for swaps
from rune to trade asset.
Big swaps have the same weight as small swaps
`,
            type: 'string'
        },
        toTradeCount: {
            description: 'Int64, count of swaps from rune to trade asset',
            type: 'string'
        },
        toTradeFees: {
            description: 'Int64(e8), the fees collected from swaps from rune to trade asset (in rune)',
            type: 'string'
        },
        toTradeVolume: {
            description: 'Int64(e8), volume of swaps from trade asset to rune denoted in rune',
            type: 'string'
        },
        toTradeVolumeUSD: {
            description: 'Int64(e2), volume of swaps from rune to trade asset denoted in USD price of the rune in each swap',
            type: 'string'
        },
        totalCount: {
            description: 'Int64, toAssetCount + toRuneCount + synthMintCount + synthRedeemCount',
            type: 'string'
        },
        totalFees: {
            description: 'Int64(e8), toAssetFees + toRuneFees + synthMintFees + synthRedeemFees',
            type: 'string'
        },
        totalVolume: {
            description: `Int64(e8),
toAssetVolume + toRuneVolume + synthMintVolume + synthRedeemVolume (denoted in rune)
`,
            type: 'string'
        },
        totalVolumeUSD: {
            description: `Int64(e2),
toAssetVolume + toRuneVolume + synthMintVolume + synthRedeemVolume (denoted in USD price of the rune in each swap)
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'toAssetCount', 'toRuneCount', 'toTradeCount', 'fromTradeCount', 'synthMintCount', 'synthRedeemCount', 'totalCount', 'toAssetVolume', 'toRuneVolume', 'toTradeVolume', 'fromTradeVolume', 'synthMintVolume', 'synthRedeemVolume', 'totalVolume', 'toAssetVolumeUSD', 'toRuneVolumeUSD', 'toTradeVolumeUSD', 'fromTradeVolumeUSD', 'synthMintVolumeUSD', 'synthRedeemVolumeUSD', 'totalVolumeUSD', 'toAssetFees', 'toRuneFees', 'toTradeFees', 'fromTradeFees', 'synthMintFees', 'synthRedeemFees', 'totalFees', 'toAssetAverageSlip', 'toRuneAverageSlip', 'synthMintAverageSlip', 'toTradeAverageSlip', 'fromTradeAverageSlip', 'synthRedeemAverageSlip', 'averageSlip', 'runePriceUSD'],
    type: 'object'
} as const;

export const SwapMetadataSchema = {
    properties: {
        affiliateAddress: {
            description: 'Affiliate fee address of the swap, empty if fee swap',
            type: 'string'
        },
        affiliateFee: {
            description: 'Int64 (Basis points, 0-1000, where 1000=10%)',
            type: 'string'
        },
        inPriceUSD: {
            description: 'in asset price usd at the first interval',
            type: 'string'
        },
        isStreamingSwap: {
            description: 'indicate whether this action was streaming',
            example: true,
            type: 'boolean'
        },
        liquidityFee: {
            description: 'Int64(e8), RUNE amount charged as swap liquidity fee',
            type: 'string'
        },
        memo: {
            description: 'Transaction memo of the swap action',
            type: 'string'
        },
        networkFees: {
            '$ref': '#/components/schemas/NetworkFees'
        },
        outPriceUSD: {
            description: 'out asset price usd at the first interval',
            type: 'string'
        },
        streamingSwapMeta: {
            '$ref': '#/components/schemas/StreamingSwapMeta'
        },
        swapSlip: {
            description: 'Int64 (Basis points, 0-10000, where 10000=100%), swap slip percentage',
            type: 'string'
        },
        swapTarget: {
            description: 'Int64(e8), minimum output amount specified for the swap',
            type: 'string'
        },
        txType: {
            description: `The type of the transaction given from its Memo.
Type of Transaction: 
"unknown", "add", "withdraw", "swap", "limitOrder", "outbound", "donate",
"bond", "unbond", "leave", "yggdrasilFund", "yggdrasilReturn", "reserve",
"refund", "migrate", "ragnarok", "switch", "noOp", "consolidate", "thorname",
"loanOpen", "loanRepayment"
`,
            example: 'loanOpen',
            type: 'string'
        }
    },
    required: ['networkFees', 'liquidityFee', 'swapSlip', 'swapTarget', 'affiliateFee', 'affiliateAddress', 'memo', 'isStreamingSwap', 'txType', 'inPriceUSD', 'outPriceUSD'],
    type: 'object'
} as const;

export const THORNameDetailsSchema = {
    properties: {
        entries: {
            description: 'List details of all chains and their addresses for a given THORName',
            items: {
                '$ref': '#/components/schemas/THORNameEntry'
            },
            type: 'array'
        },
        expire: {
            description: 'Int64, THORChain block height in which THORName expires',
            type: 'string'
        },
        owner: {
            description: "owner's THOR address",
            example: 'thor102y0m3uptg0vvudeyh00r2fnz70wq7d8y7mu2g',
            type: 'string'
        }
    },
    required: ['owner', 'expire', 'entries'],
    type: 'object'
} as const;

export const THORNameEntrySchema = {
    properties: {
        address: {
            description: 'address on blockchain',
            type: 'string'
        },
        chain: {
            description: 'blockchain',
            type: 'string'
        }
    },
    required: ['chain', 'address'],
    type: 'object'
} as const;

export const TVLHistorySchema = {
    properties: {
        intervals: {
            '$ref': '#/components/schemas/TVLHistoryIntervals'
        },
        meta: {
            '$ref': '#/components/schemas/TVLHistoryItem'
        }
    },
    required: ['meta', 'intervals'],
    type: 'object'
} as const;

export const TVLHistoryIntervalsSchema = {
    items: {
        '$ref': '#/components/schemas/TVLHistoryItem'
    },
    type: 'array'
} as const;

export const TVLHistoryItemSchema = {
    properties: {
        endTime: {
            description: 'Int64, The end time of bucket in unix timestamp',
            type: 'string'
        },
        poolsDepth: {
            items: {
                '$ref': '#/components/schemas/DepthHistoryItemPool'
            },
            type: 'array'
        },
        runePriceUSD: {
            description: `Float, the price of Rune based on the deepest USD pool at the end of the interval.
`,
            type: 'string'
        },
        startTime: {
            description: 'Int64, The beginning time of bucket in unix timestamp',
            type: 'string'
        },
        totalValueBonded: {
            description: `Int64(e8), the total amount of bonds (both active and standby) at the end of
the interval
`,
            type: 'string'
        },
        totalValueLocked: {
            description: `Int64(e8), total value locked in the chain (in rune)
This equals \`totalPooledValue + totalBondedValue\`, as it combines the liquidity
pools and bonds of the nodes.
`,
            type: 'string'
        },
        totalValuePooled: {
            description: `Int64(e8) in rune, the total pooled value (both assets and rune) in all of the pools at
the end of the interval.
Note: this is twice the aggregate Rune depth of all pools.
`,
            type: 'string'
        }
    },
    required: ['startTime', 'endTime', 'totalValuePooled', 'runePriceUSD', 'poolsDepth'],
    type: 'object'
} as const;

export const ThornameMetadataSchema = {
    properties: {
        address: {
            description: 'The CHAIN address thorname has been registered to.',
            type: 'string'
        },
        chain: {
            description: "The thorname's chain.",
            type: 'string'
        },
        expire: {
            description: 'Int64, THORChain block height in which THORName expires.',
            type: 'string'
        },
        fundAmount: {
            description: 'Int64, the amount of funding for the THORName registration.',
            type: 'string'
        },
        memo: {
            description: 'Transaction memo of thorname deposit message.',
            type: 'string'
        },
        owner: {
            description: "owner's THOR address.",
            example: 'thor102y0m3uptg0vvudeyh00r2fnz70wq7d8y7mu2g',
            type: 'string'
        },
        registrationFee: {
            description: 'Int64, the registration fee paid.',
            type: 'string'
        },
        thorname: {
            description: 'The thorname registered to the address.',
            type: 'string'
        },
        txType: {
            description: 'The type of the transaction given from its Memo.',
            type: 'string'
        }
    },
    required: ['memo', 'thorname', 'address', 'owner', 'expire', 'chain', 'fundAmount', 'registrationFee', 'txType'],
    type: 'object'
} as const;

export const TransactionSchema = {
    description: 'Transaction data',
    properties: {
        address: {
            description: 'Sender address',
            type: 'string'
        },
        affiliate: {
            description: 'if transactions flaged as affiliate',
            type: 'boolean'
        },
        coins: {
            '$ref': '#/components/schemas/Coins'
        },
        height: {
            description: `The thorchain height that the outbound transaction occurred.
`,
            type: 'string'
        },
        txID: {
            description: `Transaction id hash. Some transactions (such as outbound transactions made in the
native asset) may have a zero value.
`,
            type: 'string'
        }
    },
    required: ['txID', 'address', 'coins'],
    type: 'object'
} as const;

export const WithdrawMetadataSchema = {
    properties: {
        asymmetry: {
            description: `Decimal (-1.0 <=> 1.0), indicates how asymmetrical the withdrawal was. 0 means
totally symmetrical
`,
            type: 'string'
        },
        basisPoints: {
            description: `Int64 (Basis points, 0-10000, where 10000=100%), percentage of total pool ownership
withdrawn
`,
            type: 'string'
        },
        impermanentLossProtection: {
            description: 'Int64, additional Rune paid out because of impermanent loss protection',
            type: 'string'
        },
        liquidityUnits: {
            description: `Int64, amount of liquidity units removed from the member as result of the withdrawal
`,
            type: 'string'
        },
        memo: {
            description: 'Transaction memo of the withdraw action',
            type: 'string'
        },
        networkFees: {
            '$ref': '#/components/schemas/NetworkFees'
        }
    },
    required: ['liquidityUnits', 'asymmetry', 'basisPoints', 'networkFees', 'impermanentLossProtection', 'memo'],
    type: 'object'
} as const;